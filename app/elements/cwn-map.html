<dom-module id="cwn-map">
    <style>
        leaflet-map {
            height: 100%;
            display: relative;
        }
        .updating {
            position: absolute;
            height: 100%;
            width: 100%;
            top: 0;
            left: 0;
            z-index: 2;
            background-color: rgba(255,255,255,.6);
        }
        .updating div {
            position: absolute;
            left: 20px;
            bottom: 20px;
            font-size: 36px;
            color: #888;
            text-shadow: 2px 2px white;
        }
        #leaflet {
            width: 100%;
            height: 100%;
            display: block;
        }
    </style>

    <template>
        <div id="leaflet" fit></div>

        <div hidden$="{{!updating}}" class="updating">
            <div>Filtering...</div>
        </div>
    </template>
</dom-module>

<script>
    Polymer({
        is : 'cwn-map',

        ready : function() {
            if( !this.tid ) this.tid = 1;
            else this.tid += 1;

            console.log('ready: '+this.tid);
        },

        attached : function() {
            console.log('attached '+this.tid);
        },


        init : function(legend, filters) {
            console.log('init '+this.tid);

            this.popup = $('<div style="z-index:1000;position:absolute;padding:5px;background-color:white;border:1px solid #ccc; display:none"></div>');
            $('body').append(this.popup);

            this.map = L.map(this.$.leaflet).setView([40, -121], 5);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                maxZoom: 18
            }).addTo(this.map);

            this.links = [];
            this.filters = filters;
            this.legend = legend;
            
            var ref = this;
            var MarkerLayer = L.CanvasLayer.extend({
              render: function() {
                var canvas = this.getCanvas();
                var ctx = canvas.getContext('2d');
                // clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                ref.renderMarkers(ctx, this);
                this.redraw();
              }
            });

            this.markerLayer = new MarkerLayer();
            this.markerLayer.addTo(this.map);

            //this.map.on('zoomend', this.onZoomEnd.bind(this));
            this.map.on('mousemove', this.onMouseMove.bind(this));
            this.map.on('click', this.onClick.bind(this));

            CWN.ds.on('load', this.process.bind(this));
            if( !CWN.ds.loading ) this.process();

            setTimeout(function(){
                this.map.invalidateSize();
            }.bind(this), 200);

            setTimeout(function(){
                // just add top layer
                var layers = [];
                for( var i = 0; i < regions.subregions.length; i++ ) {
                    var name = regions.subregions[i].name;

                    for( var j = 0; j < regionsGeo.length; j++ ) {
                        if( !regionsGeo[j].properties ) continue;

                        if( regionsGeo[j].properties.id == name ) {
                            layers.push(regionsGeo[j]);
                            break;
                        } 
                    }
                }

                L.geoJson( layers ).addTo(this.map);
            }.bind(this), 1000);
        },

        onClick : function(e) {
            var node = this.getMouseOverNode(e);
            if( !node ) return;

            this.$.leaflet.style.cursor = 'default';
            this.popup.hide();
            window.location = '#info/'+node.properties.prmname;
        },

        onMouseMove : function(e) {
            var node = this.getMouseOverNode(e);
            
            if( !node ) {
                this.unselectHover();

                this.$.leaflet.style.cursor = 'default';
                this.popup.hide();
                return;
            }

            this.$.leaflet.style.cursor = 'pointer';

            var point = node.properties._render.point;
            var buffer = node.properties._render.buffer;

            this.selectHover(node);

            this.popup
                .css('top', point.y + buffer + 60)
                .css('left', point.x - buffer - 10)
                .text(node.properties.prmname)
                .show();
        },

        getMouseOverNode : function(e) {
            var p = e.containerPoint, np, buffer;

            for( var i = 0; i < CWN.ds.data.nodes.length; i++ ) {
                node = CWN.ds.data.nodes[i];

                if( !(node.properties._render.show || 
                    (node.properties._render.oneStep && this.filters.oneStepMode)) ) {
                    continue;
                }

                np = node.properties._render.point;
                if( !np ) continue;

                buffer = node.properties._render.buffer;

                if( p.x > np.x - buffer && p.x < np.x + buffer ) {
                    if( p.y > np.y - buffer && p.y < np.y + buffer ) {
                        return node;
                    }
                }
            }

            return null;
        },

        selectHover : function(node) {
            if( this.hoverNode == node ) return;
            if( this.hoverNode ) this.unselectHover();

            node.properties._render.multipier = 2;
            node.properties._render.stroke = 'blue';
            node.properties._render.lineWidth = 3;

            if( CWN.ds.originLookupMap[node.properties.prmname] ) {
                var arr = CWN.ds.originLookupMap[node.properties.prmname];
                for( var i = 0; i < arr.length; i++ ) {
                    arr[i].properties._render.highlight = 'origin';
                }
            }
            if( CWN.ds.terminalLookupMap[node.properties.prmname] ) {
                var arr = CWN.ds.terminalLookupMap[node.properties.prmname];
                for( var i = 0; i < arr.length; i++ ) {
                    arr[i].properties._render.highlight = 'terminal';
                }
            }
            
            this.markerLayer.render();
            this.hoverNode = node;
        },

        unselectHover : function() {
            if( !this.hoverNode ) return;

            this.hoverNode.properties._render.stroke = null;
            this.hoverNode.properties._render.lineWidth = null;
            this.hoverNode.properties._render.multipier = null;

            if( CWN.ds.originLookupMap[this.hoverNode.properties.prmname] ) {
                var arr = CWN.ds.originLookupMap[this.hoverNode.properties.prmname];
                for( var i = 0; i < arr.length; i++ ) {
                    arr[i].properties._render.highlight = null;
                }
            }
            if( CWN.ds.terminalLookupMap[this.hoverNode.properties.prmname] ) {
                var arr = CWN.ds.terminalLookupMap[this.hoverNode.properties.prmname];
                for( var i = 0; i < arr.length; i++ ) {
                    arr[i].properties._render.highlight = null;
                }
            }

            this.hoverNode = null;
            this.markerLayer.render();
        },

        renderMarkers : function(ctx) {
            if( !this.links ) return;
            var t = new Date().getTime();

            var node, link, point, point2, o, render, ms, color;

            var markerSize = 16;
            var zoom = this.map.getZoom()
            if( zoom > 8 && zoom < 12 ) markerSize = 22;
            else if( zoom >= 12 ) markerSize = markerSize = 36;
            var buffer = markerSize / 2;

            var bounds = this.map.getBounds();

            for( var i = 0; i < this.links.length; i++ ) {
                link = this.links[i];

                if( !this.intersectsMap(bounds, link.geometry.coordinates[0]) &&
                    !this.intersectsMap(bounds, link.geometry.coordinates[1]) ) {
                    continue;
                }

                render = link.properties._render || {};

                if( !render.show ) continue;
                
                point = this.map.latLngToContainerPoint(new L.LatLng(
                    link.geometry.coordinates[0][1],
                    link.geometry.coordinates[0][0]
                ));

                point2 = this.map.latLngToContainerPoint(new L.LatLng(
                    link.geometry.coordinates[1][1],
                    link.geometry.coordinates[1][0]
                ));

                color = 'white';
                if( link.properties._render.highlight ) {
                    if( link.properties._render.highlight == 'origin' ) color = 'green';
                    else color = 'blue';
                }

                ctx.beginPath();
                ctx.strokeStyle = color;
                ctx.lineWidth = 4;
                ctx.moveTo(point.x, point.y);
                ctx.lineTo(point2.x, point2.y);
                ctx.stroke();

                ctx.beginPath();
                ctx.strokeStyle = this.getLineColor(link);
                ctx.lineWidth = 2;
                ctx.moveTo(point.x, point.y);
                ctx.lineTo(point2.x, point2.y);
                ctx.stroke();

            }

            for( var i = 0; i < CWN.ds.data.nodes.length; i++ ) {
                node = CWN.ds.data.nodes[i];

                render = node.properties._render || {};
                render.point = null;

                if( !this.intersectsMap(bounds, node.geometry.coordinates) ) {
                    continue;
                }
                

                if( !(render.show || (render.oneStep && this.filters.oneStepMode)) ) {
                    continue;
                }

                point = this.map.latLngToContainerPoint(new L.LatLng(
                    node.geometry.coordinates[1],
                    node.geometry.coordinates[0]
                ));
                
                o = render.oneStep ? .3 : .7;

                render.point = point;
                render.buffer = buffer;
                ms = markerSize * (render.multipier || 1);
                buffer = ms / 2;

                CWN.render[node.properties.type](ctx, {
                    x: point.x-buffer, 
                    y: point.y-buffer, 
                    width: ms,
                    height: ms,
                    opacity: o,
                    fill : render.fill,
                    stroke : render.stroke,
                    lineWidth : render.lineWidth, 
                });
            }

            //console.log((new Date().getTime() - t)+'ms');
        },

        intersectsMap : function(bounds, coordinates) {
            if( bounds.contains([coordinates[1], coordinates[0]]) ) {
                return true;
            }
            return false;
        },

        process : function() {
            if( CWN.ds.loading ) return;

            this.edges = [];
            this.knownEdges = [];
            for( var i = 0; i < CWN.ds.data.length; i++ ) {
                var d = CWN.ds.data[i];

                if( d.properties.type == 'Diversion' || d.properties.type == 'Return Flow' ) {
                    this.links.push(d);
                } else {
                    this.nodes.push(d);
                }
            }

            this.update();
        },

        getLineColor : function(feature) {
            var color = CWN.colors.salmon;
            if( feature.properties.renderInfo ) {
                if( feature.properties.renderInfo.type == 'flowToSink' ) {
                  color = CWN.colors.lightGrey;
                } else if( feature.properties.renderInfo.type == 'returnFlowFromDemand' ) {
                    color = CWN.colors.red;
                } else if( feature.properties.renderInfo.type == 'gwToDemand' ) {
                    color = CWN.colors.black;
                } else if( feature.properties.renderInfo.type == 'artificalRecharge' ) {
                    color = CWN.colors.purple;
                }
            }

            var line = {
                color: color,
                weight: 3,
                opacity: 0.4,
                smoothFactor: 1
            }

            if( feature.properties.calibrationNode && this.filters.calibrationMode ) {
                line.color = 'blue';
            }

            return color;
        },

        update : function() {
            this.updating = true;

            var map = this.map;
            var oneStepMode = this.filters.oneStepMode;

            // update filtering
            this.filter();

            this.links = this.getEdgeMarkers();

            this.markerLayer.render();

            this.updating = false;
            this.fire('filtering-complete');
        },

        getEdgeMarkers : function() {
            var x2, y2, i, coord, link, markers = [];

            for( i = 0; i < CWN.ds.data.links.length; i++ ) {
                link = CWN.ds.data.links[i];
                if( !link.properties._render.show ) continue;
                coord = link.geometry.coordinates;
                
                x2 = (coord[0][0] + coord[1][0]) / 2;
                y2 = (coord[0][1] + coord[1][1]) / 2;

                x2 = (x2 + coord[1][0]) / 2;
                y2 = (y2 + coord[1][1]) / 2;

                markers.push(link);
            }

            return markers;
        },

        // marker nodes that are linked to a visible node with the 'nodeStep' attribute
        filter : function() {
            var re, i, d, d2, d3, id;

            // three loops, first mark nodes that match, then mark one step nodes
            // finally mark links to hide and show


            try {
                re = new RegExp('.*'+this.filters.text.toLowerCase()+'.*');
            } catch (e) {}

            for( i = 0; i < CWN.ds.data.nodes.length; i++ ) {
                d = CWN.ds.data.nodes[i];

                if( !d.properties._render ) {
                    d.properties._render = {
                        filter_id : d.properties.type.replace(' ','_').replace('-','_')
                    };
                }
                d.properties._render.oneStep = false;

                
                if( this.filters[d.properties._render.filter_id] && this.isTextMatch(re, d.properties) ) {
                    if( !this.filters.calibrationMode && d.properties.calibrationNode ) {
                        d.properties._render.show = false;
                    } else {
                        d.properties._render.show = true;
                    }
                } else {
                    d.properties._render.show = false;
                }
            }

            // now mark one step nodes
            for( i = 0; i < CWN.ds.data.nodes.length; i++ ) {
                d = CWN.ds.data.nodes[i];
                if( d.properties._render.show ) continue;
                if( !this.filters.calibrationMode && d.properties.calibrationNode ) continue;

                if( d.properties.terminals ) {
                    for( var j = 0; j < d.properties.terminals.length; j++ ) {
                        d2 = CWN.ds.lookupMap[d.properties.terminals[j]];
                        if( d2 && d2.properties._render.show ) {
                            d.properties._render.oneStep = true;
                            break;
                        }
                    }
                }
                if( d.properties.origins && !d.properties._render.oneStep) {
                    for( var j = 0; j < d.properties.origins.length; j++ ) {
                        d2 = CWN.ds.lookupMap[d.properties.origins[j]];
                        if( d2 && d2.properties._render.show ) {
                            d.properties._render.oneStep = true;
                            break;
                        }
                    }
                }
            }

            // now mark links that should be show
            for( var i = 0; i < CWN.ds.data.links.length; i++ ) {
                d = CWN.ds.data.links[i];
                if( !d.properties._render ) {
                    d.properties._render = {};
                }

                d2 = CWN.ds.lookupMap[d.properties.origin];
                d3 = CWN.ds.lookupMap[d.properties.terminus];
                if( d2 && d3 && 
                    (d2.properties._render.show || (this.filters.oneStepMode && d2.properties._render.oneStep) ) && 
                    (d3.properties._render.show || (this.filters.oneStepMode && d3.properties._render.oneStep) ) &&
                   !(d2.properties._render.oneStep && d3.properties._render.oneStep ) ) {
                    d.properties._render.show = true;
                } else {
                    d.properties._render.show = false;
                }
            }
        },

        isTextMatch : function(re, props) {
            if( this.filters.text == '' || !re ) return true;

            if( re.test(props.prmname.toLowerCase()) ) return true;
            if( props.description && re.test(props.description.toLowerCase()) ) return true;
            return false;
        }
    });
</script>