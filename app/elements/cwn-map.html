<dom-module id="cwn-map">
    <style>
        :host {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }
        leaflet-map {
            height: 100%;
            display: relative;
            z-index: 100;
        }
        cwn-map-menu {
            z-index: 101;
        }
        .updating {
            position: absolute;
            height: 100%;
            width: 100%;
            top: 0;
            left: 0;
            z-index: 2;
            background-color: rgba(255,255,255,.6);
        }
        .updating div {
            position: absolute;
            left: 20px;
            bottom: 20px;
            font-size: 36px;
            color: #888;
            text-shadow: 2px 2px white;
        }
        #leaflet {
            width: 100%;
            height: 100%;
            display: block;
        }
    </style>

    <template>
        <cwn-map-menu id="menu"
          on-select="onRegionSelect"
          on-hover="onMenuRegionHover"
          on-nohover="onMenuRegionNoHover">
        </cwn-map-menu>
        <div id="leaflet">

        </div>

        <div hidden$="{{!updating}}" class="updating">
            <div>Filtering...</div>
        </div>

        <!--<cwn-region-selector id="selector"></cwn-region-selector>-->
    </template>
</dom-module>

<script>
    Polymer({
        is : 'cwn-map',

        ready : function() {
          this.customLines = [];
        },

        init : function(legend, filters) {
            //console.log('init '+this.tid);

            this.popup = $('<div style="z-index:1000;position:absolute;padding:5px;background-color:white;border:1px solid #ccc; display:none"></div>');
            $('body').append(this.popup);

            this.map = L.map(this.$.leaflet).setView([40, -121], 5);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                maxZoom: 18
            }).addTo(this.map);

            this.links = [];
            this.mapFilters = filters || {};

            this.legend = legend;

            this.mouseMoveTimer = -1;

            this.renderState = {
              points : [],
              lines : [],
              polygons : []
            }

            var ref = this;

            //this.map.on('zoomend', this.onZoomEnd.bind(this));

            //this.map.on('mousemove', this.onMouseMove.bind(this));
            //this.map.on('mouseout', this.onMouseOut.bind(this));
            //this.map.on('click', this.onClick.bind(this));




            /*var MarkerLayer = L.CanvasLayer.extend({
              render: function() {
                var canvas = this.getCanvas();
                var ctx = canvas.getContext('2d');
                // clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                ref.renderMarkers(ctx, this);
                this.redraw();
              }
            });

            this.markerLayer = new MarkerLayer();
            this.markerLayer.addTo(this.map);
            */

            this.markerLayer = new L.CanvasGeojsonLayer({
              onMouseOver : function(features) {
                for( var i = 0; i < features.length; i++ ) {
                  if( !features[i].properties._render ) features[i].properties._render = {};
                  features[i].properties._render.hover = true;
                }
              },
              onMouseOut : function(features) {
                for( var i = 0; i < features.length; i++ ) {
                  if( !features[i].properties._render ) features[i].properties._render = {};
                  features[i].properties._render.hover = false;
                }
              },
              onClick : function(features) {
                if( features.length > 0 ) {
                  ref.onRegionClick(features[0].properties.id);
                }
              }
            });
            this.markerLayer.addTo(this.map);

            //this.$.selector.init(this.map, this.markerLayer);

            CWN.ds.on('load', this.process.bind(this));
            if( !CWN.ds.loading ) this.process();

            setTimeout(function(){
                this.map.invalidateSize();
            }.bind(this), 200);
        },

        onClick : function(e) {
            var node = this.getMouseOverNode(e);
            if( !node ) {
              var region = this.getMouseOverRegion(e);

              if( region ) {
                $('.menu-item[name="'+region.name+'"]').trigger('click');
              }

              return;
            }

            this.$.leaflet.style.cursor = 'default';
            this.popup.hide();
            window.location = '#info/'+node.properties.prmname;
        },

        onMouseOut : function() {
          setTimeout(function(){
            // for region
            this.$.menu.setHovered(null);

            // for marker
            //this.unselectHover();
            this.$.leaflet.style.cursor = 'default';
            this.popup.hide();
          }.bind(this), 200);
        },

        onMouseMove : function(e) {
        return;
        //  if( this.mouseMoveTimer != -1 ) clearTimeout(this.mouseMoveTimer);

        //  this.mouseMoveTimer = setTimeout(function(){
        //    this.mouseMoveTimer = -1;

        /*    this._onMouseMove(e); */
        //    var region = this.getMouseOverRegion(e);
        //    this.$.menu.setHovered(region);
        //  }.bind(this), 50);
        },

        render : function(ctx, xyPoints, map, feature) {
          var render = feature.geojson.properties._render || {};

          if( feature.geojson.geometry.type == 'Point' ) {

            o = render.oneStep ? .3 : .7;

            render.point = xyPoints;
            ms = (feature.size || 20) * (render.multipier || 1);
            buffer = ms / 2;

            CWN.render[feature.geojson.properties.type](ctx, {
                x: xyPoints.x,
                y: xyPoints.y,
                width: ms,
                height: ms,
                opacity: o,
                fill : render.fill,
                stroke : render.stroke,
                lineWidth : render.lineWidth,
            });

          } else if ( feature.geojson.geometry.type == 'LineString' ) {

            color = 'white';
            if( render.highlight ) {
                if( render.highlight == 'origin' ) color = 'green';
                else color = 'red';
            }

            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = 4;
            ctx.moveTo(xyPoints[0].x, xyPoints[0].y);
            ctx.lineTo(xyPoints[1].x, xyPoints[1].y);
            ctx.stroke();

            ctx.beginPath();
            ctx.strokeStyle = this.getLineColor(feature.geojson);
            ctx.lineWidth = 2;
            ctx.moveTo(xyPoints[0].x, xyPoints[0].y);
            ctx.lineTo(xyPoints[1].x, xyPoints[1].y);
            ctx.stroke();

          } else if ( feature.geojson.geometry.type == 'Polygon' ) {

            this.drawRegion(ctx, xyPoints, render, this);

          }

        },

        drawRegion : function(ctx, xyPoints, config, feature) {
          var point;
          if( xyPoints.length <= 1 ) return;

          ctx.beginPath();

          point = xyPoints[0];
          ctx.moveTo(point.x, point.y);
          for( var i = 1; i < xyPoints.length; i++ ) {
            ctx.lineTo(xyPoints[i].x, xyPoints[i].y);
          }
          ctx.lineTo(xyPoints[0].x, xyPoints[0].y);

          ctx.strokeStyle = config.hover ? 'red' : 'rgba('+CWN.colors.rgb.blue.join(',')+',.8)';
          ctx.fillStyle = config.fillStyle ? config.fillStyle : 'rgba('+CWN.colors.rgb.blue.join(',')+',.4)';
          ctx.lineWidth = 4;

          ctx.stroke();
          ctx.fill();

          // draw center
          /*if( !config.noCenteriod ) {
            ctx.beginPath();
            try {
              point = this.map.latLngToContainerPoint([region.center[1], region.center[0]]);
            } catch(e) {
              debugger;
            }
            ctx.arc(point.x, point.y, 25, 0, 2*Math.PI);
            ctx.stroke();
            ctx.fill();

            // add name
            ctx.fillStyle = '#333333';
            ctx.font="14px \"Helvetica Neue\",Helvetica,Arial,sans-serif";
            ctx.fillText(region.name, point.x - 20, point.y + 40 );
          }*/
        },


        process : function() {
            if( CWN.ds.loading ) return;

            this.edges = [];
            this.knownEdges = [];
            /*for( var i = 0; i < CWN.ds.data.length; i++ ) {
                var d = CWN.ds.data[i];

                if( d.properties.type == 'Diversion' || d.properties.type == 'Return Flow' ) {
                    this.links.push(d);

                } else {
                    this.nodes.push(d);
                }
            }*/

            var self = this;
            for( var i = 0; i < CWN.ds.data.regions.length; i++ ) {
              this.markerLayer.addFeature({
                geojson: CWN.ds.data.regions[i].geo,
                render: function(ctx, xyPoints, map){
                  self.render(ctx, xyPoints, map, this);
                }
              })
            }

            for( var i = 0; i < CWN.ds.data.links.length; i++ ) {
              this.markerLayer.addFeature({
                geojson: CWN.ds.data.links[i],
                render: function(ctx, xyPoints, map){
                  self.render(ctx, xyPoints, map, this);
                }
              })
            }

            for( var i = 0; i < CWN.ds.data.nodes.length; i++ ) {
              this.markerLayer.addFeature({
                geojson: CWN.ds.data.nodes[i],
                render: function(ctx, xyPoint, map){
                  self.render(ctx, xyPoint, map, this);
                }
              })
            }



            this.$.menu.init();

            this.updateRenderState();
            this.update();
        },

        getLineColor : function(feature) {
            var color = CWN.colors.salmon;
            if( feature.properties.renderInfo ) {
                if( feature.properties.renderInfo.type == 'flowToSink' ) {
                  color = CWN.colors.lightGrey;
                } else if( feature.properties.renderInfo.type == 'returnFlowFromDemand' ) {
                    color = CWN.colors.red;
                } else if( feature.properties.renderInfo.type == 'gwToDemand' ) {
                    color = CWN.colors.black;
                } else if( feature.properties.renderInfo.type == 'artificalRecharge' ) {
                    color = CWN.colors.purple;
                }
            }

            var line = {
                color: color,
                weight: 3,
                opacity: 0.4,
                smoothFactor: 1
            }

            if( feature.properties.calibrationNode && this.mapFilters.calibrationMode ) {
                line.color = 'blue';
            }

            return color;
        },

        update : function() {
            this.updating = true;

            if( !this.mapFilters ) this.mapFilters = {};

            var map = this.map;
            var oneStepMode = this.mapFilters.oneStepMode;

            // update filtering
            this.filter();

            this.links = this.getEdgeMarkers();

            if( this.markerLayer ) this.markerLayer.render();

            this.updating = false;
            this.fire('filtering-complete');
        },

        getEdgeMarkers : function() {
            var x2, y2, i, coord, link, markers = [];

            for( i = 0; i < CWN.ds.data.links.length; i++ ) {
                link = CWN.ds.data.links[i];
                if( !link.properties._render.show ) continue;
                coord = link.geometry.coordinates;

                x2 = (coord[0][0] + coord[1][0]) / 2;
                y2 = (coord[0][1] + coord[1][1]) / 2;

                x2 = (x2 + coord[1][0]) / 2;
                y2 = (y2 + coord[1][1]) / 2;

                markers.push(link);
            }

            return markers;
        },

        // marker nodes that are linked to a visible node with the 'nodeStep' attribute
        filter : function() {
            var re, i, d, d2, d3, id;

            // three loops, first mark nodes that match, then mark one step nodes
            // finally mark links to hide and show
            try {
                re = new RegExp('.*'+this.mapFilters.text.toLowerCase()+'.*');
            } catch (e) {}

            for( i = 0; i < CWN.ds.data.nodes.length; i++ ) {
                d = CWN.ds.data.nodes[i];

                if( !d.properties._render ) {
                    d.properties._render = {
                        filter_id : d.properties.type.replace(' ','_').replace('-','_')
                    };
                }
                d.properties._render.oneStep = false;


                if( this.mapFilters[d.properties._render.filter_id] && this.isTextMatch(re, d.properties) ) {
                    if( !this.mapFilters.calibrationMode && d.properties.calibrationNode ) {
                        d.properties._render.show = false;
                    } else {
                        d.properties._render.show = true;
                    }
                } else {
                    d.properties._render.show = false;
                }
            }

            // now mark one step nodes
            for( i = 0; i < CWN.ds.data.nodes.length; i++ ) {
                d = CWN.ds.data.nodes[i];
                if( d.properties._render.show ) continue;
                if( !this.mapFilters.calibrationMode && d.properties.calibrationNode ) continue;

                if( d.properties.terminals ) {
                    for( var j = 0; j < d.properties.terminals.length; j++ ) {
                        d2 = CWN.ds.lookupMap[d.properties.terminals[j]];
                        if( d2 && d2.properties._render.show ) {
                            d.properties._render.oneStep = true;
                            break;
                        }
                    }
                }
                if( d.properties.origins && !d.properties._render.oneStep) {
                    for( var j = 0; j < d.properties.origins.length; j++ ) {
                        d2 = CWN.ds.lookupMap[d.properties.origins[j]];
                        if( d2 && d2.properties._render.show ) {
                            d.properties._render.oneStep = true;
                            break;
                        }
                    }
                }
            }

            // now mark links that should be show
            for( var i = 0; i < CWN.ds.data.links.length; i++ ) {
                d = CWN.ds.data.links[i];
                if( !d.properties._render ) {
                    d.properties._render = {};
                }

                d2 = CWN.ds.lookupMap[d.properties.origin];
                d3 = CWN.ds.lookupMap[d.properties.terminus];
                if( d2 && d3 &&
                    (d2.properties._render.show || (this.mapFilters.oneStepMode && d2.properties._render.oneStep) ) &&
                    (d3.properties._render.show || (this.mapFilters.oneStepMode && d3.properties._render.oneStep) ) &&
                   !(d2.properties._render.oneStep && d3.properties._render.oneStep ) ) {
                    d.properties._render.show = true;
                } else {
                    d.properties._render.show = false;
                }
            }
        },

        isTextMatch : function(re, props) {
            if( this.mapFilters.text == '' || !re ) return true;

            if( re.test(props.prmname.toLowerCase()) ) return true;
            if( props.description && re.test(props.description.toLowerCase()) ) return true;
            return false;
        },

        onRegionClick : function(name) {
          $('.menu-item[name="'+name+'"]').trigger('click');
        },

        onRegionSelect : function(e) {
          this.updateRenderState();
          this.markerLayer.render();
        },

        updateRenderState : function() {
          this.renderState = {
            points : [],
            lines : [],
            polygons : []
          }
          this.clearCustomLines();

          this._updateRenderState('California');

          var f = null;
          for( var i = 0; i < this.markerLayer.features.length; i++ ) {
            f = this.markerLayer.features[i];

            if( this.renderState.points.indexOf(f.geojson) > -1 ||
              this.renderState.lines.indexOf(f.geojson) > -1 ||
              this.renderState.polygons.indexOf(f.geojson) > -1  ) {
                f.visible = true;
            } else {
              f.visible = false;
            }
          }
          console.log('set render state');
          this.markerLayer.render();
        },

        _updateRenderState : function(name) {
          var region = CWN.ds.regionLookupMap[name];
          var state = this.$.menu.state;

          if( state.enabled.indexOf(name) > -1 ) {
            this._addStateNodes(region.nodes, state);

            if( !region.subregions ) return;

            for( var i = 0; i < region.subregions.length; i++ ) {
              this._updateRenderState(region.subregions[i]);
            }
          } else {

            if( name != 'California' ) this.renderState.polygons.push(region.geo);
          }
        },

        _addStateNodes : function(nodes, state) {
          var self = this;

          for( var i = 0; i < nodes.length; i++ ) {
            var node = CWN.ds.filenameLookupMap[nodes[i]];

            // TODO: why!?
            if( !node ) continue;

            if( node.properties.type == 'Diversion' || node.properties.type == 'Return Flow' ) {
              var terminal = this._getStateNodeLocation(node.properties.terminus, state);
              var origin = this._getStateNodeLocation(node.properties.origin, state);

              // BADNESS
              if( !origin || !terminal ) {
                if( !origin ) console.log('Not drawing link: '+node.properties.prmname+'.  missing origin: '+node.properties.origin);
                if( !terminal ) console.log('Not drawing link: '+node.properties.prmname+'.  missing terminus: '+node.properties.terminus);
                continue;
              }

              /*this.renderState.lines.push({
                "type" : "Feature",
                "geometry" : {
                  "type" : "LineString",
                  coordinates : [origin, terminal]
                },
                properties : node.properties
              });*/
              var lineFeature = {
                geojson : {
                  "type" : "Feature",
                  "geometry" : {
                    "type" : "LineString",
                    coordinates : [origin, terminal]
                  },
                  properties : $.extend(true, {}, node.properties)
                },
                render : function(ctx, xyPoints, map) {
                  // TODO: need to render lines
                  // Also need to group between features.

                  self.render(ctx, xyPoints, map, this);
                }
              };
              lineFeature.geojson.properties.debug = true;

              this.customLines.push(lineFeature);
              this.renderState.lines.push(lineFeature.geojson);
              this.markerLayer.addFeature(lineFeature);

            } else {

              this.renderState.points.push(node);

            }
          }
        },

        clearCustomLines : function() {
          for( var i = this.customLines.length; i >= 0; i-- ) {
            var index = this.markerLayer.features.indexOf(this.customLines[i]);
            if( index > -1 ) this.markerLayer.features.splice(index, 1);
          }
          this.customLines = [];
        },

        _getStateNodeLocation : function(name, state) {
          var node = CWN.ds.lookupMap[name];

          for( var i = 0; i < node.properties.regions.length; i++ ) {
            if( state.disabled.indexOf(node.properties.regions[i]) > -1 ) {
              if( CWN.ds.regionLookupMap[node.properties.regions[i]].center ) {
                return CWN.ds.regionLookupMap[node.properties.regions[i]].center;
              }
            }
          }

          return node.geometry.coordinates || [0,0];
        },

        onMenuRegionHover : function(e) {
          this.hoverRegion = e.detail;
          this.markerLayer.render();
        },

        onMenuRegionNoHover : function(e) {
          if( this.hoverRegion == e.detail ) {
            this.hoverRegion = null;
            this.markerLayer.render();
          }
        }


    });
</script>
