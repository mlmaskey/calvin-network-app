<polymer-element name="cwn-map" attributes="ds filters legend">
    <template>
        <style>
            leaflet-map {
                height: 100%
            }
        </style>
        <leaflet-map id="leaflet" content tab="true" longitude="-121.00" latitude="40.00" zoom="5"></leaflet-map>
    </template>
    <script>
        Polymer('cwn-map', {
            ds : null,

            markerLayer : null,
            edgeLayer : null,

            observe : {
                'ds.loading' : 'update',
                '$.leaflet.map' : 'update',
                'filters.calibrationMode' : 'update',
                'filters.Junction_Node' : 'update'
            },

            _process : function() {
                if( this.ds.loading || !this.$.leaflet.map ) return;

                this.edges = [];
                this.knownEdges = [];
                for( var i = 0; i < this.ds.data.length; i++ ) {
                    var d = this.ds.data[i];

                    if( d.properties.type == 'Diversion' ) {
                        this.links.push(d);
                    } else {
                        this.nodes.push(d);
                    }
                }

                this.update();
            },

            // TODO: this data sucks... needs to be cleaned up!
            _addEdge : function(edge, type) {
                if( edge == null ) return;

                var pts = edge.split('_');
                if( pts.length <= 1 ) return;
                if( !this.ds.dataMap[pts[0]] || !this.ds.dataMap[pts[1]] ) return;
                if( !this.ds.dataMap[pts[0]].geometry || !this.ds.dataMap[pts[1]].geometry ) return;

                // only add edge once
                if( this.knownEdges.indexOf(edge) > -1 || this.knownEdges.indexOf(pts[1]+'_'+pts[0]) > -1 ) return;
                this.knownEdges.push(edge);

                this.edges.push({
                    type : 'Feature',
                    geometry : {
                        type: 'LineString',
                        coordinates : [
                            this.ds.dataMap[pts[0]].geometry.coordinates,
                            this.ds.dataMap[pts[1]].geometry.coordinates 
                        ]
                    },
                    properties : {
                        name : edge
                        //edgeType : type
                    }
                });
            },

            update : function() {
                if( this.ds.loading || !this.$.leaflet.map ) return;

                var map = this.$.leaflet.map;

                if( !L.MyMarker ) this.initMarker();

                if( this.markerLayer ) map.removeLayer(this.markerLayer);
                if( this.edgeLayer ) map.removeLayer(this.edgeLayer);

                // update filtering
                this._filter();

                this.edgeLayer = L.geoJson(this.ds.data.links, {
                    style: function(feature) {
                        return {
                            color: 'red',
                            weight: 3,
                            opacity: 0.4,
                            smoothFactor: 1
                        }
                    }
                }).addTo(map);
                this.edgeLayer.on('click', function(e){
                    this.fire('selected', e.layer.feature);
                });
                

                this.markerLayer = L.geoJson(this.ds.data.nodes, {
                    pointToLayer: function(feature, ll) {
                        return this._getMarker(feature, ll);
                    }.bind(this)
                    /*,filter: function(feature, layer) {
                        return this.filters[feature.properties.type.replace(' ','_')];
                    }.bind(this)*/
                }).addTo(map);
                this.markerLayer.on('click', function(e){
                    this.fire('selected', e.layer.feature);
                }.bind(this));

                this.markerLayer.on('touch', function(e){
                    this.fire('selected', e.layer.feature);
                }.bind(this));

                

            },

            // marker nodes that are linked to a visible node with the 'nodeStep' attribute
            _filter : function() {
                var i, d, id;
                for( i = 0; i < this.ds.data; i++ ) {
                    d = this.ds.data[i];
                    
                    if( !d.properties._render ) d.properties._render = {};
                    d.properties._render.oneStep = false;

                    id = properties.type.replace(' ','_');
                    if( this.filters[id] ) return;

                    for( var i = 0; i < d.properties.terminals.length; i++ ) {
                        if( !d.properties.terminals ) continue;

                        // TODO
                    }
                }
            },

            _getMarker : function(feature, ll) {
                var render = feature.properties._render || {};
                var type = feature.properties.type;

                var options = {
                    radius : 20,
                    color : '#333',
                    fillColor : this.legend[feature.properties.type] ? 
                                    this.legend[feature.properties.type].color : '#000000',
                    opacity: render.oneStep ? .4 : .9,
                    fillOpacity : render.oneStep ? .2 : .7
                };

                if( this.filters.calibrationMode && feature.properties.calibrationMode ) {
                    options.radius = 20,
                    options.strokeWidth = '3';
                    if( feature.properties.calibrationMode == 'both' ) options.color = 'red';
                    else if( feature.properties.calibrationMode == 'in' ) options.color = 'yellow';
                    else if( feature.properties.calibrationMode == 'out' ) options.color = 'blue';
                }
                

                if( type == 'Junction' || type == 'Pump Plant' || type == 'Power Plant' ) {

                    return L.circleMarker(ll, options);

                } else if ( type == 'Water Treatment' ) {

                    options.sides = 6;
                    return L.myMarker(ll, options);
                
                } else if ( type == 'Surface Storage' || type == 'Groundwater Storage' ) {

                    options.sides = 3;
                    options.rotate = 90;
                    return L.myMarker(ll, options);

                } else if ( type == 'Agricultural Demand' || type == 'Urban Demand' ) {

                    options.sides = 5;
                    options.rotate = 18;
                    return L.myMarker(ll, options);

                } else {

                    options.sides = 4;
                    options.rotate = 45;
                    return L.myMarker(ll, options);

                }
            },

            initMarker : function() {
                // add custom marker
                L.MyMarker = L.CircleMarker.extend({

                    initialize: function (latlng, options) {
                        L.Circle.prototype.initialize.call(this, latlng, null, options);
                        this._radius = this.options.radius;
                        this._sides = this.options.sides ? this.options.sides : 6;
                        this._rotate = this.options.rotate ? this.options.rotate : 0;
                    },


                    getPathString: function () {
                        var p = this._point;
                        if (this._checkIfEmpty()) {
                            return '';
                        }

                        if (L.Browser.svg) {
                            return this.polygon(p.x, p.y, this._radius, this._sides, this._rotate);
                        } else {
                            console.error("MyMarker not using svg!!!");
                        }
                    },

                    polygon : function(x, y, radius, sides, startAngle) {
                      if (sides < 3) return;
                      var a = ((Math.PI * 2)/sides);
                      var r = startAngle * (Math.PI / 180);

                      // think you need to adjust by x, y
                      var p = "M";
                      for (var i = 0; i < sides; i++) {
                         p += (x+(radius*Math.cos(a*i-r)))+","+(y+(radius*Math.sin(a*i-r)))+" ";
                      }
                      p +=" z";
                      return p;
                    }

                });

                L.myMarker = function (latlng, options) {
                    return new L.MyMarker(latlng, options);
                };
            }
        });
    </script>
</polymer-element>