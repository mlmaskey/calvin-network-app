<polymer-element name="cwn-map" attributes="ds filters legend">
    <template>
        <link rel="stylesheet" href="../components/leaflet/dist/leaflet.css" />
        <style>
            leaflet-map {
                height: 100%
            }
            .updating {
                position: absolute;
                height: 100%;
                width: 100%;
                top: 0;
                left: 0;
                z-index: 2;
                background-color: rgba(255,255,255,.6);
            }
            .updating div {
                position: absolute;
                left: 20px;
                bottom: 20px;
                font-size: 36px;
                color: #888;
                text-shadow: 2px 2px white;
            }
            #leaflet {
                width: 100%;
                height: 100%;
                display: block;
            }
        </style>
        <div id="leaflet"></div>

        <!--<leaflet-map id="leaflet" content tab="true" longitude="-121.00" latitude="40.00" zoom="5"></leaflet-map>-->
        <div hidden?="{{!updating}}" class="updating">
            <div>Filtering...</div>
        </div>
    </template>
    <script>
        Polymer('cwn-map', {
            ds : null,

            markerLayer : null,
            edgeLayer : null,

            observe : {
                'ds.loading' : 'update',
                'map' : 'update',
                'filters.calibrationMode' : 'update',
                'filters.oneStepMode' : 'update',
                'filters.Junction' : 'update',
                'filters.Power_Plant'  : 'update',
                'filters.Agricultural_Demand'  : 'update',
                'filters.Pump_Plant' : 'update',
                'filters.Water_Treatment' : 'update',
                'filters.Surface_Storage' : 'update',
                'filters.Urban_Demand' : 'update',
                'filters.Sink'  : 'update',
                'filters.Groundwater_Storage' : 'update',
                'filters.Non_Standard_Demand' : 'update',
                'filters.text' : 'update'
            },

            updating: false,

            map : null,

            ready : function() {
                this._process();
            },

            domReady : function() {
                this.async(function(){
                    this.map = L.map(this.$.leaflet).setView([40, -121], 5);
                    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                        maxZoom: 18
                    }).addTo(this.map);

                    this.map.on('zoomend', this._onZoomEnd.bind(this));
                });
            },

            _process : function() {
                if( !this.ds ) return;
                if( this.ds.loading || !this.map ) return;

                this.edges = [];
                this.knownEdges = [];
                for( var i = 0; i < this.ds.data.length; i++ ) {
                    var d = this.ds.data[i];

                    if( d.properties.type == 'Diversion' || d.properties.type == 'Return Flow' ) {
                        this.links.push(d);
                    } else {
                        this.nodes.push(d);
                    }
                }

                this.update();
            },

            // TODO: this data sucks... needs to be cleaned up!
            _addEdge : function(edge, type) {
                if( edge == null ) return;

                var pts = edge.split('_');
                if( pts.length <= 1 ) return;
                if( !this.ds.dataMap[pts[0]] || !this.ds.dataMap[pts[1]] ) return;
                if( !this.ds.dataMap[pts[0]].geometry || !this.ds.dataMap[pts[1]].geometry ) return;

                // only add edge once
                if( this.knownEdges.indexOf(edge) > -1 || this.knownEdges.indexOf(pts[1]+'_'+pts[0]) > -1 ) return;
                this.knownEdges.push(edge);

                this.edges.push({
                    type : 'Feature',
                    geometry : {
                        type: 'LineString',
                        coordinates : [
                            this.ds.dataMap[pts[0]].geometry.coordinates,
                            this.ds.dataMap[pts[1]].geometry.coordinates 
                        ]
                    },
                    properties : {
                        name : edge
                        //edgeType : type
                    }
                });
            },

            update : function() {
                if( this.ds.loading || !this.map ) return;
                this.updating = true;

                setTimeout(function(){
                    var map = this.map;
                    var oneStepMode = this.filters.oneStepMode;

                    if( !L.MyMarker ) {
                        this.initMoveEvents();
                        this.initMarker();
                    }

                    if( this.markerLayer ) map.removeLayer(this.markerLayer);
                    if( this.edgeLayer ) map.removeLayer(this.edgeLayer);

                    // update filtering
                    this._filter();

                    var lineMarkers = this.getEdgeMarkers();


                    var calibrationMode = this.filters.calibrationMode;
                    this.edgeLayer = L.geoJson(lineMarkers, {
                        style: function(feature) {
                            var color = CWN.colors.salmon;
                            if( feature.properties.renderInfo ) {
                                if( feature.properties.renderInfo.type == 'flowToSink' ) {
                                  color = CWN.colors.lightGrey;
                                } else if( feature.properties.renderInfo.type == 'returnFlowFromDemand' ) {
                                    color = CWN.colors.red;
                                } else if( feature.properties.renderInfo.type == 'gwToDemand' ) {
                                    color = CWN.colors.black;
                                } else if( feature.properties.renderInfo.type == 'artificalRecharge' ) {
                                    color = CWN.colors.purple;
                                }
                            }

                            var line = {
                                color: color,
                                weight: 3,
                                opacity: 0.4,
                                smoothFactor: 1
                            }

                            if( feature.properties.calibrationNode && calibrationMode ) {
                                line.color = 'blue';
                            }
                            return line;
                        },
                        pointToLayer: function (feature, latlng) {
                            return this._getLineMarker(feature, latlng);
                        }.bind(this),
                        filter: function(feature, layer) {
                            return feature.properties._render.show;
                        }
                    }).addTo(map);

                    this.edgeLayer.on('click', function(e){
                        this.fire('selected', e.layer.feature);
                    }.bind(this));
                    
                    for( var key in this.edgeLayer._layers ) {
                        this._hackTouchEvent(this.edgeLayer._layers[key]);
                    }

                    this.markerLayer = L.geoJson(this.ds.data.nodes, {
                        pointToLayer: function(feature, ll) {
                            return this._getMarker(feature, ll);
                        }.bind(this),
                        filter: function(feature, layer) {
                            return feature.properties._render.show || 
                                    (feature.properties._render.oneStep && oneStepMode);
                        }
                    }).addTo(map);
                    this.markerLayer.on('click', function(e){
                        this.fire('selected', e.layer.feature);
                    }.bind(this));

                    for( var key in this.markerLayer._layers ) {
                        this._hackTouchEvent(this.markerLayer._layers[key]);
                    }

                    this.updating = false;
                    this.fire('filtering-complete');
                }.bind(this), 250);
                
            },

            getEdgeMarkers : function() {
                var x2, y2, i, coord, link, markers = [];

                for( i = 0; i < this.ds.data.links.length; i++ ) {
                    link = this.ds.data.links[i];
                    if( !link.properties._render.show ) continue;
                    coord = link.geometry.coordinates;
                    
                    x2 = (coord[0][0] + coord[1][0]) / 2;
                    y2 = (coord[0][1] + coord[1][1]) / 2;

                    x2 = (x2 + coord[1][0]) / 2;
                    y2 = (y2 + coord[1][1]) / 2;

                    markers.push(link);
                    markers.push({
                        type: "Point", 
                        coordinates : [x2, y2],
                        properties : link.properties
                    });
                }

                return markers;
            },

            // marker nodes that are linked to a visible node with the 'nodeStep' attribute
            _filter : function() {
                var re, i, d, d2, d3, id;

                // three loops, first mark nodes that match, then mark one step nodes
                // finally mark links to hide and show


                try {
                    re = new RegExp('.*'+this.filters.text.toLowerCase()+'.*');
                } catch (e) {}

                for( i = 0; i < this.ds.data.nodes.length; i++ ) {
                    d = this.ds.data.nodes[i];
                    
                    if( !d.properties._render ) {
                        d.properties._render = {
                            filter_id : d.properties.type.replace(' ','_').replace('-','_')
                        };
                    }
                    d.properties._render.oneStep = false;

                    
                    if( this.filters[d.properties._render.filter_id] && this._isTextMatch(re, d.properties) ) {
                        if( !this.filters.calibrationMode && d.properties.calibrationNode ) {
                            d.properties._render.show = false;
                        } else {
                            d.properties._render.show = true;
                        }
                    } else {
                        d.properties._render.show = false;
                    }
                }

                // now mark one step nodes
                for( i = 0; i < this.ds.data.nodes.length; i++ ) {
                    d = this.ds.data.nodes[i];
                    if( d.properties._render.show ) continue;
                    if( !this.filters.calibrationMode && d.properties.calibrationNode ) continue;

                    if( d.properties.terminals ) {
                        for( var j = 0; j < d.properties.terminals.length; j++ ) {
                            d2 = this.ds.lookupMap[d.properties.terminals[j]];
                            if( d2 && d2.properties._render.show ) {
                                d.properties._render.oneStep = true;
                                break;
                            }
                        }
                    }
                    if( d.properties.origins && !d.properties._render.oneStep) {
                        for( var j = 0; j < d.properties.origins.length; j++ ) {
                            d2 = this.ds.lookupMap[d.properties.origins[j]];
                            if( d2 && d2.properties._render.show ) {
                                d.properties._render.oneStep = true;
                                break;
                            }
                        }
                    }
                }

                // now mark links that should be show
                for( var i = 0; i < this.ds.data.links.length; i++ ) {
                    d = this.ds.data.links[i];
                    if( !d.properties._render ) {
                        d.properties._render = {};
                    }

                    d2 = this.ds.lookupMap[d.properties.origin];
                    d3 = this.ds.lookupMap[d.properties.terminus];
                    if( d2 && d3 && 
                        (d2.properties._render.show || (this.filters.oneStepMode && d2.properties._render.oneStep) ) && 
                        (d3.properties._render.show || (this.filters.oneStepMode && d3.properties._render.oneStep) ) &&
                       !(d2.properties._render.oneStep && d3.properties._render.oneStep ) ) {
                        d.properties._render.show = true;
                    } else {
                        d.properties._render.show = false;
                    }
                }
            },

            _isTextMatch : function(re, props) {
                if( this.filters.text == '' || !re ) return true;

                if( re.test(props.prmname.toLowerCase()) ) return true;
                if( props.description && re.test(props.description.toLowerCase()) ) return true;
                return false;
            },

            _onZoomEnd : function() {
                if( this.markerLayer ) this.map.removeLayer(this.markerLayer);

                this.markerLayer = L.geoJson(this.ds.data.nodes, {
                    pointToLayer: function(feature, ll) {
                        return this._getMarker(feature, ll);
                    }.bind(this),
                    filter: function(feature, layer) {
                        return feature.properties._render.show || 
                                (feature.properties._render.oneStep && this.filters.oneStepMode);
                    }.bind(this)
                }).addTo(this.map);
                this.markerLayer.on('click', function(e){
                    this.fire('selected', e.layer.feature);
                }.bind(this));

                for( var key in this.markerLayer._layers ) {
                    this._hackTouchEvent(this.markerLayer._layers[key]);
                }
            },

            _getMarker : function(feature, ll) {
                var render = feature.properties._render || {};
                var type = feature.properties.type;

                if( this.map.getZoom() < 10 ) {
                    s = this.map.getZoom() * 3;
                } else {
                    s = this.map.getZoom() * 4;
                }

                var options = {
                    iconSize : new L.Point(s, s),
                    type : type
                };

                /*if( this.filters.calibrationMode && feature.properties.calibrationMode ) {
                    options.radius = 30,
                    options.weight = 7;
                    if( feature.properties.calibrationMode == 'both' ) options.color = 'red';
                    else if( feature.properties.calibrationMode == 'in' ) options.color = 'yellow';
                    else if( feature.properties.calibrationMode == 'out' ) options.color = 'blue';
                }*/

                var m = new L.Marker(ll, {
                    icon: new L.Icon.Canvas(options), 
                    opacity: render.oneStep ? .1 : .7
                });

                return m;
            },

            _getLineMarker : function(feature, ll) {
                if( this.map.getZoom() < 10 ) {
                    s = this.map.getZoom() * 3;
                } else {
                    s = this.map.getZoom() * 4;
                }

                var options = {
                    iconSize : new L.Point(s, s),
                    renderInfo : feature.properties.renderInfo || {}
                };

                var m = new L.Marker(ll, {
                    icon: new L.Icon.LineCanvas(options)
                });

                return m;
            },

            // hack so we know if the map is moving for touch events
            lastMove : -1,
            mapMoving : false,
            initMoveEvents : function() {
                this.map.on('movestart', function(){
                    this.mapMoving = true;
                }.bind(this));
                this.map.on('moveend', function(){
                    this.lastMove = new Date().getTime();
                    this.mapMoving = false;
                }.bind(this));
            },

            _hackTouchEvent : function(marker) {
                $(marker._container).on('touchend', function(e){
                    setTimeout(function(){
                        var timeFromLastMove = new Date().getTime() - this.lastMove;
                        // make sure the map is not moving and has actually been settled for 300ms
                        if( !this.mapMoving && timeFromLastMove > 300 ) {
                            this.fire('selected', marker.feature);
                        }

                    // wait 50ms seconds to check to make sure map.movestart has had a chance to fire
                    }.bind(this), 50);
                }.bind(this));
            },

            initMarker : function() {
                // can we pass in type and then just use
                L.Icon.Canvas = L.Icon.extend({
                    options: {
                        iconSize: new L.Point(20, 20), // Have to be supplied
                        className: 'leaflet-canvas-icon'
                    },

                    createIcon: function () {
                        var e = document.createElement('canvas');
                        this._setIconStyles(e, 'icon');
                        var s = this.options.iconSize;
                        e.width = s.x;
                        e.height = s.y;
                        this.draw(e.getContext('2d'), s.x, s.y);
                        return e;
                    },

                    createShadow: function () {
                        return null;
                    },

                    draw: function(ctx, width, height) {
                        CWN.render[this.options.type](ctx, 2, 2, width-4, height-4);
                    }
                });

                L.Icon.LineCanvas = L.Icon.extend({
                    options: {
                        iconSize: new L.Point(20, 20), // Have to be supplied
                        className: 'leaflet-canvas-icon'
                    },
                    _transformProps : ['webkitTransform', 'MozTransform', 'msTransform', 'transform'],

                    createIcon: function () {
                        var icon = document.createElement('div');
                        var canvas = document.createElement('canvas');
                        icon.appendChild(canvas);

                        this._setIconStyles(icon, 'icon');

                        var s = this.options.iconSize;
                        canvas.width = s.x;
                        canvas.height = s.y;
                        this.draw(canvas.getContext('2d'), s.x, s.y);

                        // now we need to rotate the icon
                        var rotate = this.options.renderInfo.rotate || 0;
                        console.log(rotate);

                        for( var i = 0; i < this._transformProps.length; i++ ) {
                            canvas.style[this._transformProps[i]] = 'rotate('+rotate+'deg)';
                        }

                        return icon;
                    },

                    createShadow: function () {
                        return null;
                    },

                    draw: function(ctx, width, height) {
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(width, 0);
                        ctx.lineTo(width, height);
                        ctx.lineTo(0, height);
                        ctx.moveTo(0, 0);
                        ctx.closePath();
                        ctx.stroke();

                        var mX = 5;
                        var mY = height / 2;
                        var vX = 10;
                        var vY = 10;


                        if( this.options.renderInfo ) {
                          for( var key in CWN.render.lineMarkers ) {
                            if( this.options.renderInfo[key] ) {
                              CWN.render.lineMarkers[key](ctx, mX, mY, 4, vX, vY);
                              mX += vX * 1.75;
                              mY += vY * 1.75;
                            }
                          }
                        }
                    }
                });
            }
        });
    </script>
</polymer-element>