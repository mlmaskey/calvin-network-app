<dom-module id="cwn-map">
    <style>
        leaflet-map {
            height: 100%;
            display: relative;
        }
        .updating {
            position: absolute;
            height: 100%;
            width: 100%;
            top: 0;
            left: 0;
            z-index: 2;
            background-color: rgba(255,255,255,.6);
        }
        .updating div {
            position: absolute;
            left: 20px;
            bottom: 20px;
            font-size: 36px;
            color: #888;
            text-shadow: 2px 2px white;
        }
        #leaflet {
            width: 100%;
            height: 100%;
            display: block;
        }
    </style>

    <template>
        <div id="leaflet" fit></div>

        <div hidden$="{{!updating}}" class="updating">
            <div>Filtering...</div>
        </div>
    </template>
</dom-module>

<script>
    Polymer({
        is : 'cwn-map',

        configure : function() {
            return {
                updating: false,
                filters : {},
                map : null,
                ds : null,

                markerLayer : null,
                edgeLayer : null,
                redrawMarkerSizesTimer : -1
            }
        },

        ready : function() {
            this.firstRender = true;
            CWN.ds.on('load', this.process.bind(this));
        },

        init : function(legend, filters) {
            this.filters = filters;
            this.legend = legend;
            
            this.map = L.map(this.$.leaflet).setView([40, -121], 5);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                maxZoom: 18
            }).addTo(this.map);

            this.map.on('zoomend', this.onZoomEnd.bind(this));

        },

        process : function() {
            debugger;
            if( CWN.ds.loading ) return;

            this.edges = [];
            this.knownEdges = [];
            for( var i = 0; i < CWN.ds.data.length; i++ ) {
                var d = CWN.ds.data[i];

                if( d.properties.type == 'Diversion' || d.properties.type == 'Return Flow' ) {
                    this.links.push(d);
                } else {
                    this.nodes.push(d);
                }
            }

            this.update();
        },

        // TODO: this data sucks... needs to be cleaned up!
        addEdge : function(edge, type) {
            if( edge == null ) return;

            var pts = edge.split('_');
            if( pts.length <= 1 ) return;
            if( !CWN.ds.dataMap[pts[0]] || !CWN.ds.dataMap[pts[1]] ) return;
            if( !CWN.ds.dataMap[pts[0]].geometry || !CWN.ds.dataMap[pts[1]].geometry ) return;

            // only add edge once
            if( this.knownEdges.indexOf(edge) > -1 || this.knownEdges.indexOf(pts[1]+'_'+pts[0]) > -1 ) return;
            this.knownEdges.push(edge);

            this.edges.push({
                type : 'Feature',
                geometry : {
                    type: 'LineString',
                    coordinates : [
                        CWN.ds.dataMap[pts[0]].geometry.coordinates,
                        CWN.ds.dataMap[pts[1]].geometry.coordinates 
                    ]
                },
                properties : {
                    name : edge
                    //edgeType : type
                }
            });
        },

        update : function() {
            this.updating = true;

            setTimeout(function(){
                var map = this.map;
                var oneStepMode = this.filters.oneStepMode;

                if( this.firstRender ) {
                    this.initMoveEvents();
                }

                if( this.markerLayer ) map.removeLayer(this.markerLayer);
                if( this.edgeLayer ) map.removeLayer(this.edgeLayer);

                // update filtering
                this.filter();

                var lineMarkers = this.getEdgeMarkers();


                var calibrationMode = this.filters.calibrationMode;
                this.edgeLayer = L.geoJson(lineMarkers, {
                    style: function(feature) {
                        var color = CWN.colors.salmon;
                        if( feature.properties.renderInfo ) {
                            if( feature.properties.renderInfo.type == 'flowToSink' ) {
                              color = CWN.colors.lightGrey;
                            } else if( feature.properties.renderInfo.type == 'returnFlowFromDemand' ) {
                                color = CWN.colors.red;
                            } else if( feature.properties.renderInfo.type == 'gwToDemand' ) {
                                color = CWN.colors.black;
                            } else if( feature.properties.renderInfo.type == 'artificalRecharge' ) {
                                color = CWN.colors.purple;
                            }
                        }

                        var line = {
                            color: color,
                            weight: 3,
                            opacity: 0.4,
                            smoothFactor: 1
                        }

                        if( feature.properties.calibrationNode && calibrationMode ) {
                            line.color = 'blue';
                        }
                        return line;
                    },
                    pointToLayer: function (feature, latlng) {
                        return this.getLineMarker(feature, latlng);
                    }.bind(this),
                    filter: function(feature, layer) {
                        return feature.properties._render.show;
                    }.bind(this)
                }).addTo(map);

                this.edgeLayer.on('click', function(e){
                    this.fire('selected', e.layer.feature);
                }.bind(this));
                
                for( var key in this.edgeLayer._layers ) {
                    this.hackTouchEvent(this.edgeLayer._layers[key]);
                }


                this.markerLayer = L.geoJson(CWN.ds.data.nodes, {
                    pointToLayer: function(feature, ll) {
                        return this.getMarker(feature, ll);
                    }.bind(this),
                    filter: function(feature, layer) {
                        return feature.properties._render.show || 
                                (feature.properties._render.oneStep && oneStepMode);
                    }
                }).addTo(map);
                this.markerLayer.on('click', function(e){
                    this.fire('selected', e.layer.feature);
                }.bind(this));

                for( var key in this.markerLayer._layers ) {
                    this.hackTouchEvent(this.markerLayer._layers[key]);
                }

                this.updating = false;
                this.fire('filtering-complete');

                this.firstRender = false;
            }.bind(this), 250);
            
        },

        getEdgeMarkers : function() {
            var x2, y2, i, coord, link, markers = [];

            for( i = 0; i < CWN.ds.data.links.length; i++ ) {
                link = CWN.ds.data.links[i];
                if( !link.properties._render.show ) continue;
                coord = link.geometry.coordinates;
                
                x2 = (coord[0][0] + coord[1][0]) / 2;
                y2 = (coord[0][1] + coord[1][1]) / 2;

                x2 = (x2 + coord[1][0]) / 2;
                y2 = (y2 + coord[1][1]) / 2;

                markers.push(link);
            }

            return markers;
        },

        // marker nodes that are linked to a visible node with the 'nodeStep' attribute
        filter : function() {
            var re, i, d, d2, d3, id;

            // three loops, first mark nodes that match, then mark one step nodes
            // finally mark links to hide and show


            try {
                re = new RegExp('.*'+this.filters.text.toLowerCase()+'.*');
            } catch (e) {}

            for( i = 0; i < CWN.ds.data.nodes.length; i++ ) {
                d = CWN.ds.data.nodes[i];

                if( !d.properties._render ) {
                    d.properties._render = {
                        filter_id : d.properties.type.replace(' ','_').replace('-','_')
                    };
                }
                d.properties._render.oneStep = false;

                
                if( this.filters[d.properties._render.filter_id] && this.isTextMatch(re, d.properties) ) {
                    if( !this.filters.calibrationMode && d.properties.calibrationNode ) {
                        d.properties._render.show = false;
                    } else {
                        d.properties._render.show = true;
                    }
                } else {
                    d.properties._render.show = false;
                }
            }

            // now mark one step nodes
            for( i = 0; i < CWN.ds.data.nodes.length; i++ ) {
                d = CWN.ds.data.nodes[i];
                if( d.properties._render.show ) continue;
                if( !this.filters.calibrationMode && d.properties.calibrationNode ) continue;

                if( d.properties.terminals ) {
                    for( var j = 0; j < d.properties.terminals.length; j++ ) {
                        d2 = CWN.ds.lookupMap[d.properties.terminals[j]];
                        if( d2 && d2.properties._render.show ) {
                            d.properties._render.oneStep = true;
                            break;
                        }
                    }
                }
                if( d.properties.origins && !d.properties._render.oneStep) {
                    for( var j = 0; j < d.properties.origins.length; j++ ) {
                        d2 = CWN.ds.lookupMap[d.properties.origins[j]];
                        if( d2 && d2.properties._render.show ) {
                            d.properties._render.oneStep = true;
                            break;
                        }
                    }
                }
            }

            // now mark links that should be show
            for( var i = 0; i < CWN.ds.data.links.length; i++ ) {
                d = CWN.ds.data.links[i];
                if( !d.properties._render ) {
                    d.properties._render = {};
                }

                d2 = CWN.ds.lookupMap[d.properties.origin];
                d3 = CWN.ds.lookupMap[d.properties.terminus];
                if( d2 && d3 && 
                    (d2.properties._render.show || (this.filters.oneStepMode && d2.properties._render.oneStep) ) && 
                    (d3.properties._render.show || (this.filters.oneStepMode && d3.properties._render.oneStep) ) &&
                   !(d2.properties._render.oneStep && d3.properties._render.oneStep ) ) {
                    d.properties._render.show = true;
                } else {
                    d.properties._render.show = false;
                }
            }
        },

        isTextMatch : function(re, props) {
            if( this.filters.text == '' || !re ) return true;

            if( re.test(props.prmname.toLowerCase()) ) return true;
            if( props.description && re.test(props.description.toLowerCase()) ) return true;
            return false;
        },

        onZoomEnd : function() {
/* WHY AGAIN 
            for( var key in this.markerLayer._layers ) {
                this._hackTouchEvent(this.markerLayer._layers[key]);
            }
*/
            //this.redrawMarkerSizes();

            if( this.map.getZoom() < 10 ) {
                $('.LineCanvas').hide();
            } else {
                $('.LineCanvas').show();
            }
        },

        // check sizes

        redrawMarkerSizes : function() {
        
            if( this.redrawMarkerSizesTimer != -1 ) {
                clearTimeout(this.redrawMarkerSizesTimer);
            }

            this.redrawMarkerSizesTimer = setTimeout(function(){
                this.redrawMarkerSizesTimer = -1;
                this.redrawMarkerSizes();
            }.bind(this), 2000);
        },

        redrawMarkerSizes : function() {
            console.log('redrawing');
            if( this.markerLayer ) this.map.removeLayer(this.markerLayer);

            this.markerLayer = L.geoJson(CWN.ds.data.nodes, {
                pointToLayer: function(feature, ll) {
                    return this.getMarker(feature, ll);
                }.bind(this),
                filter: function(feature, layer) {
                    if( !feature ) return false;
                    return feature.properties._render.show || 
                            (feature.properties._render.oneStep && this.filters.oneStepMode);
                }.bind(this)
            }).addTo(this.map);

            this.markerLayer.on('click', function(e){
                this.fire('selected', e.layer.feature);
            }.bind(this));
        },

        getMarker : function(feature, ll) {
            var render = feature.properties._render || {};
            var type = feature.properties.type;

            /*
            TODO: this is too slow right now :(
            if( this.map.getZoom() < 10 ) {
                s = this.map.getZoom() * 3;
            } else {
                s = this.map.getZoom() * 4;
            }

            var options = {
                iconSize : new L.Point(s, s),
                type : type
            };
            */
            var options = {
                iconSize : new L.Point(24, 24),
                type : type,
                name : feature.properties.prmname
            };
  

            var m = new L.Marker(ll, {
                icon: new L.Icon.Canvas(options), 
                opacity: render.oneStep ? .1 : .7
            });

            return m;
        },

        getLineMarker : function(feature, ll) {
            var hide = false;

            if( this.map.getZoom() < 10 ) {
                s = this.map.getZoom() * 3;
                hide = true;
            } else {
                s = this.map.getZoom() * 4;
            }

            var options = {
                iconSize : new L.Point(s, s),
                renderInfo : feature.properties.renderInfo || {},
                hide : hide
            };

            var m = new L.Marker(ll, {
                icon: new L.Icon.LineCanvas(options)
            });

            return m;
        },

        // hack so we know if the map is moving for touch events
        lastMove : -1,
        mapMoving : false,
        initMoveEvents : function() {
            this.map.on('movestart', function(){
                this.mapMoving = true;
            }.bind(this));
            this.map.on('moveend', function(){
                this.lastMove = new Date().getTime();
                this.mapMoving = false;
            }.bind(this));
        },

        hackTouchEvent : function(marker) {
            $(marker._container).on('touchend', function(e){
                setTimeout(function(){
                    var timeFromLastMove = new Date().getTime() - this.lastMove;
                    // make sure the map is not moving and has actually been settled for 300ms
                    if( !this.mapMoving && timeFromLastMove > 300 ) {
                        this.fire('selected', marker.feature);
                    }

                // wait 50ms seconds to check to make sure map.movestart has had a chance to fire
                }.bind(this), 50);
            }.bind(this));
        }
    });
</script>