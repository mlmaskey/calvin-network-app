<polymer-element name="cwn-map" attributes="ds filters legend">
    <template>
        <link rel="stylesheet" href="../../components/leaflet/dist/leaflet.css" />
        <style>
            leaflet-map {
                height: 100%
            }
            .updating {
                position: absolute;
                height: 100%;
                width: 100%;
                top: 0;
                left: 0;
                z-index: 2;
                background-color: rgba(255,255,255,.6);
            }
            .updating div {
                position: absolute;
                left: 20px;
                bottom: 20px;
                font-size: 36px;
                color: #888;
                text-shadow: 2px 2px white;
            }
            #leaflet {
                width: 100%;
                height: 100%;
                display: block;
            }
        </style>
        <div id="leaflet"></div>

        <!--<leaflet-map id="leaflet" content tab="true" longitude="-121.00" latitude="40.00" zoom="5"></leaflet-map>-->
        <div hidden?="{{!updating}}" class="updating">
            <div>Filtering...</div>
        </div>
    </template>
    <script>
        Polymer('cwn-map', {
            ds : null,

            markerLayer : null,
            edgeLayer : null,

            observe : {
                'ds.loading' : 'update',
                '$.leaflet.map' : 'update',
                'filters.calibrationMode' : 'update',
                'filters.Junction' : 'update',
                'filters.Power_Plant'  : 'update',
                'filters.Agricultural_Demand'  : 'update',
                'filters.Pump_Plant' : 'update',
                'filters.Water_Treatment' : 'update',
                'filters.Surface_Storage' : 'update',
                'filters.Urban_Demand' : 'update',
                'filters.Sink'  : 'update',
                'filters.Groundwater_Storage' : 'update',
                'filters.Non_Standard_Demand' : 'update',
                'filters.text' : 'update'
            },

            updating: false,

            map : null,

            domReady : function() {
                this.async(function(){
                    this.map = L.map(this.$.leaflet).setView([40, -121], 5);
                    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                        maxZoom: 18
                    }).addTo(this.map);
                });
            },

            _process : function() {
                if( this.ds.loading || !this.map ) return;

                this.edges = [];
                this.knownEdges = [];
                for( var i = 0; i < this.ds.data.length; i++ ) {
                    var d = this.ds.data[i];

                    if( d.properties.type == 'Diversion' ) {
                        this.links.push(d);
                    } else {
                        this.nodes.push(d);
                    }
                }

                this.update();
            },

            // TODO: this data sucks... needs to be cleaned up!
            _addEdge : function(edge, type) {
                if( edge == null ) return;

                var pts = edge.split('_');
                if( pts.length <= 1 ) return;
                if( !this.ds.dataMap[pts[0]] || !this.ds.dataMap[pts[1]] ) return;
                if( !this.ds.dataMap[pts[0]].geometry || !this.ds.dataMap[pts[1]].geometry ) return;

                // only add edge once
                if( this.knownEdges.indexOf(edge) > -1 || this.knownEdges.indexOf(pts[1]+'_'+pts[0]) > -1 ) return;
                this.knownEdges.push(edge);

                this.edges.push({
                    type : 'Feature',
                    geometry : {
                        type: 'LineString',
                        coordinates : [
                            this.ds.dataMap[pts[0]].geometry.coordinates,
                            this.ds.dataMap[pts[1]].geometry.coordinates 
                        ]
                    },
                    properties : {
                        name : edge
                        //edgeType : type
                    }
                });
            },

            update : function() {
                if( this.ds.loading || !this.map ) return;
                this.updating = true;

                setTimeout(function(){
                    var map = this.map;

                    if( !L.MyMarker ) {
                        this.initMoveEvents();
                        this.initMarker();
                    }

                    if( this.markerLayer ) map.removeLayer(this.markerLayer);
                    if( this.edgeLayer ) map.removeLayer(this.edgeLayer);

                    // update filtering
                    this._filter();

                    var calibrationMode = this.filters.calibrationMode;
                    this.edgeLayer = L.geoJson(this.ds.data.links, {
                        style: function(feature) {
                            var line = {
                                color: 'red',
                                weight: 3,
                                opacity: 0.4,
                                smoothFactor: 1
                            }

                            if( feature.properties.calibrationNode && calibrationMode ) {
                                line.color = 'blue';
                            }
                            return line;
                        },
                        filter: function(feature, layer) {
                            return feature.properties._render.show;
                        }
                    }).addTo(map);
                    this.edgeLayer.on('click', function(e){
                        this.fire('selected', e.layer.feature);
                    }.bind(this));
                    
                    for( var key in this.edgeLayer._layers ) {
                        this._hackTouchEvent(this.edgeLayer._layers[key]);
                    }

                    this.markerLayer = L.geoJson(this.ds.data.nodes, {
                        pointToLayer: function(feature, ll) {
                            return this._getMarker(feature, ll);
                        }.bind(this),
                        filter: function(feature, layer) {
                            return feature.properties._render.show || feature.properties._render.oneStep;
                        }
                    }).addTo(map);
                    this.markerLayer.on('click', function(e){
                        this.fire('selected', e.layer.feature);
                    }.bind(this));

                    for( var key in this.markerLayer._layers ) {
                        this._hackTouchEvent(this.markerLayer._layers[key]);
                    }

                    this.updating = false;
                }.bind(this), 200);
                
            },

            _hackTouchEvent : function(marker) {
                $(marker._container).on('touchend', function(e){
                    setTimeout(function(){
                        if( !this.mapMoving ) this.fire('selected', marker.feature);
                    }.bind(this), 50);
                }.bind(this));
            },

            // marker nodes that are linked to a visible node with the 'nodeStep' attribute
            _filter : function() {
                var re, i, d, d2, d3, id;

                // three loops, first mark nodes that match, then mark one step nodes
                // finally mark links to hide and show


                try {
                    re = new RegExp('.*'+this.filters.text.toLowerCase()+'.*');
                } catch (e) {}

                for( i = 0; i < this.ds.data.nodes.length; i++ ) {
                    d = this.ds.data.nodes[i];
                    
                    if( !d.properties._render ) {
                        d.properties._render = {
                            filter_id : d.properties.type.replace(' ','_').replace('-','_')
                        };
                    }
                    d.properties._render.oneStep = false;

                    
                    if( this.filters[d.properties._render.filter_id] && this._isTextMatch(re, d.properties) ) {
                        d.properties._render.show = true;
                    } else {
                        d.properties._render.show = false;
                    }
                }

                // now mark one step nodes
                for( i = 0; i < this.ds.data.nodes.length; i++ ) {
                    d = this.ds.data.nodes[i];
                    if( d.properties._render.show ) continue;

                    if( d.properties.terminals ) {
                        for( var j = 0; j < d.properties.terminals.length; j++ ) {
                            d2 = this.ds.lookupMap[d.properties.terminals[j]];
                            if( d2 && d2.properties._render.show ) {
                                d.properties._render.oneStep = true;
                                break;
                            }
                        }
                    }
                    if( d.properties.origins && !d.properties._render.oneStep) {
                        for( var j = 0; j < d.properties.origins.length; j++ ) {
                            d2 = this.ds.lookupMap[d.properties.origins[j]];
                            if( d2 && d2.properties._render.show ) {
                                d.properties._render.oneStep = true;
                                break;
                            }
                        }
                    }
                }

                // now mark links that should be show
                for( var i = 0; i < this.ds.data.links.length; i++ ) {
                    d = this.ds.data.links[i];
                    if( !d.properties._render ) {
                        d.properties._render = {};
                    }

                    d2 = this.ds.lookupMap[d.properties.origin];
                    d3 = this.ds.lookupMap[d.properties.terminus];
                    if( d2 && d3 && 
                        (d2.properties._render.show || d2.properties._render.oneStep ) && 
                        (d3.properties._render.show || d3.properties._render.oneStep ) ) {
                        d.properties._render.show = true;
                    } else {
                        d.properties._render.show = false;
                    }
                }

            },

            _isTextMatch : function(re, props) {
                if( this.filters.text == '' || !re ) return true;

                if( re.test(props.prmname.toLowerCase()) ) return true;
                if( props.description && re.test(props.description.toLowerCase()) ) return true;
                return false;
            },

            _getMarker : function(feature, ll) {
                var render = feature.properties._render || {};
                var type = feature.properties.type;

                var options = {
                    radius : 20,
                    color : '#333',
                    fillColor : this.legend[feature.properties.type] ? 
                                    this.legend[feature.properties.type].color : '#000000',
                    opacity: render.oneStep ? .3 : .9,
                    fillOpacity : render.oneStep ? .1 : .7
                };

                if( this.filters.calibrationMode && feature.properties.calibrationMode ) {
                    options.radius = 30,
                    options.weight = 7;
                    if( feature.properties.calibrationMode == 'both' ) options.color = 'red';
                    else if( feature.properties.calibrationMode == 'in' ) options.color = 'yellow';
                    else if( feature.properties.calibrationMode == 'out' ) options.color = 'blue';
                }
                

                if( type == 'Junction' || type == 'Pump Plant' || type == 'Power Plant' ) {

                    return L.circleMarker(ll, options);

                } else if ( type == 'Water Treatment' ) {

                    options.sides = 6;
                    return L.myMarker(ll, options);
                
                } else if ( type == 'Surface Storage' || type == 'Groundwater Storage' ) {

                    options.sides = 3;
                    options.rotate = 90;
                    return L.myMarker(ll, options);

                } else if ( type == 'Agricultural Demand' || type == 'Urban Demand' ) {

                    options.sides = 5;
                    options.rotate = 18;
                    return L.myMarker(ll, options);

                } else {

                    options.sides = 4;
                    options.rotate = 45;
                    return L.myMarker(ll, options);

                }
            },

            // hack so we know if the map is moving for touch events
            mapMoving : false,
            initMoveEvents : function() {
                this.map.on('movestart', function(){
                    this.mapMoving = true;
                }.bind(this));
                this.map.on('moveend', function(){
                    this.mapMoving = false;
                }.bind(this));
            },

            initMarker : function() {
                // add custom marker
                L.MyMarker = L.CircleMarker.extend({

                    initialize: function (latlng, options) {
                        L.Circle.prototype.initialize.call(this, latlng, null, options);
                        this._radius = this.options.radius;
                        this._sides = this.options.sides ? this.options.sides : 6;
                        this._rotate = this.options.rotate ? this.options.rotate : 0;
                    },


                    getPathString: function () {
                        var p = this._point;
                        if (this._checkIfEmpty()) {
                            return '';
                        }

                        if (L.Browser.svg) {
                            return this.polygon(p.x, p.y, this._radius, this._sides, this._rotate);
                        } else {
                            console.error("MyMarker not using svg!!!");
                        }
                    },

                    polygon : function(x, y, radius, sides, startAngle) {
                      if (sides < 3) return;
                      var a = ((Math.PI * 2)/sides);
                      var r = startAngle * (Math.PI / 180);

                      // think you need to adjust by x, y
                      var p = "M";
                      for (var i = 0; i < sides; i++) {
                         p += (x+(radius*Math.cos(a*i-r)))+","+(y+(radius*Math.sin(a*i-r)))+" ";
                      }
                      p +=" z";
                      return p;
                    }

                });

                L.myMarker = function (latlng, options) {
                    return new L.MyMarker(latlng, options);
                };
            }
        });
    </script>
</polymer-element>