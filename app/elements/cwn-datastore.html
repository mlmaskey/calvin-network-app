<polymer-element name="cwn-datastore" attributes="settings">
    <template></template>
    <script>
        Polymer('cwn-datastore', {
            loading : true,
            
            network : 'default',

            data : {
                nodes : [],
                links : [],
                default : {
                    links : [],
                    nodes : []
                },
                custom : {
                    links : [],
                    nodes : []
                }
            },
            // look up any node or terminal by prmname
            lookupMap : {},
            // look up any link origin name
            originLookupMap : {},
            terminalLookupMap : {},

            loadingCharts : true,
            chartLoadHandlers : [],

            ready : function() {
                // elements that need charts can push to this array callbacks for when charts are loaded
                window.chartLoadHandlers = this.chartLoadHandlers;
                window.ds = this;

                google.load("visualization", '1', {
                    packages:['corechart', 'table'],
                    callback : function() {
                        this.loadingCharts = false;
                        for( var i = 0; i < this.chartLoadHandlers.length; i++ ) {
                            this.chartLoadHandlers[i]();
                        }
                    }.bind(this)
                });

                this.init();
            },

            init : function(callback) {
                this.reset();
                this.callback = callback;
                this.reload();
            },

            reset : function() {
                this.loading = true;
                this.data = {
                    nodes : [],
                    links : [],
                    default : {
                        links : [],
                        nodes : []
                    },
                    custom : {
                        links : [],
                        nodes : []
                    }
                };
                this.lookupMap = {};
                this.originLookupMap = {};
                this.terminalLookupMap = {};
            },

            reload : function() {
                this.loadNetwork(this.network, function(err){
                    this.loading = false;
                    this.fire('loaded');
                    if( this.callback ) this.callback(err);
                }.bind(this));
            },

            loadNetwork : function(network, callback) {
                var url = window.location.protocol+'//'+window.location.host+'/rest/getNetwork';
                url += '?network='+network;

                $.ajax({
                    url : url,
                    success : function(resp) {
                        for( var i = 0; i < resp.nodes.length; i++ ) {
                            try {
                                d = JSON.parse(resp.nodes[i]);
                                this._processNode(d);
                            } catch (e) {
                                debugger;
                            }
                        }
                        for( var i = 0; i < resp.links.length; i++ ) {
                            try {
                                d = JSON.parse(resp.links[i]);
                                this._processLink(d);
                            } catch (e) {
                                debugger;
                            }
                        }

                        // we don't care about the custom network
                        if( this.network == 'default') {
                            callback();
                        } else {
                            // we want to load the default network
                            if( network == 'default' ) this.loadNetwork('default');
                            // we loaded the default network
                            else callback();
                        }
                    }.bind(this),
                    error : function(resp) {
                        alert('Error retrieving data from network: '+network);
                        callback(true);
                    }.bind(this)
                });
            },

            _processNode : function(node) {
                if( !node ) return;
                if( !node.properties ) return;
                if( !node.properties.prmname ) return;

                this._markCalibrationNode(node);
                
                if( !this.lookupMap[node.properties.prmname] ) {
                    this.data.nodes.push(node);
                }

                this.lookupMap[node.properties.prmname] = node;

                if( node.properties.network == 'default') {
                    this.data.default.nodes.push(node);
                } else {
                    this.data.custom.nodes.push(node);
                }
            },

            _processLink : function(link) {
                if( !link ) return;
                if( !link.properties ) return;
                if( !link.properties.prmname ) return;

                // mark if this node is a calibration or not
                this._markCalibrationNode(link);

                // 
                this._markLinkTypes(link);

                if( !this.lookupMap[link.properties.prmname] ) {
                    this.data.links.push(link);
                }

                this.lookupMap[link.properties.prmname] = link;

                // set the origin lookup map
                if( !this.originLookupMap[link.properties.origin] ) {
                    this.originLookupMap[link.properties.origin] = [link];
                } else {
                    this.originLookupMap[link.properties.origin].push(link);
                }

                // set the terminal lookup map
                if( !this.terminalLookupMap[link.properties.terminus] ) {
                    this.terminalLookupMap[link.properties.terminus] = [link];
                } else {
                    this.terminalLookupMap[link.properties.terminus].push(link);
                }


                if( link.properties.network == 'default') {
                    this.data.default.links.push(link);
                } else {
                    this.data.custom.links.push(link);
                }
            },

            _markLinkTypes : function(link) {
                link.properties.renderInfo = {
                    cost : link.properties.hasCosts ? true : false,
                    amplitude : link.properties.amplitude ? true : false,
                    // TODO: parser needs to sheet shortcut for contraint type
                    // data will still need to be loaded on second call
                    constraints : link.properties.hasConstraints ? true : false,
                    environmental : link.properties.hasClimate ? true : false
                };

                // Flow to a sink
                if( this.lookupMap[link.properties.terminus] && 
                    this.lookupMap[link.properties.terminus].properties.type == 'Sink' ) {
                    link.properties.renderInfo.type = 'flowToSink';
                
                } else if( link.properties.type == 'Return Flow' ) {
                    link.properties.renderInfo.type = 'returnFlowFromDemand';

                } else if ( this._isGWToDemand(link) ) {
                    link.properties.renderInfo.type = 'gwToDemand';

                } else if( this.lookupMap[link.properties.origin] && 
                    this.lookupMap[link.properties.origin].properties.calibrationMode == 'in' ||
                    this.lookupMap[link.properties.origin].properties.calibrationMode == 'both' ) {

                    link.properties.renderInfo.type = 'artificalRecharge';
                } else {

                    link.properties.renderInfo.type = 'unknown';
                }

            },

            _isGWToDemand : function(link) {
                var origin = this.lookupMap[link.properties.origin];
                var terminal = this.lookupMap[link.properties.terminal];

                if( !origin || !terminal ) return false;

                if( origin.properties.type != 'Groundwater Storage' ) return false;
                if( terminal.properties.type == 'Non-Standard Demand' || 
                    terminal.properties.type == 'Agricultural Demand' ||
                    terminal.properties.type == 'Urban Demand' ) return true;

                return false;
            },

            _markCalibrationNode : function(node) {
                if( node.properties.prmname.indexOf('_') > -1 ) {
                    var parts = node.properties.prmname.split('_');
                    if( !(parts[0].match(/^CN.*/) || parts[1].match(/^CN.*/)) ) {
                        return;
                    }
                } else if( !node.properties.prmname.match(/^CN.*/) ) {
                    return;
                }

                var hasIn = false;
                var hasOut = false;

                if( node.properties.terminals ) {
                    for( var i = 0; i < node.properties.terminals.length; i++ ) {
                        if( node.properties.terminals[i] != null ) {
                            hasOut = true;
                            break;
                        }
                    }
                }
                if( node.properties.origins ) {
                    for( var i = 0; i < node.properties.origins.length; i++ ) {
                        if( node.properties.origins[i] != null ) {
                            hasIn = true;
                            break;
                        }
                    }
                } 

                node.properties.calibrationNode = true;
                if( !hasIn && !hasOut ) return;
                
                if( hasIn && hasOut ) node.properties.calibrationMode = 'both';
                else if ( hasIn ) node.properties.calibrationMode = 'in';
                else if ( hasOut ) node.properties.calibrationMode = 'out';
            }
        })
    </script>
</polymer-element>