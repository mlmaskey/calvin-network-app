<polymer-element name="cwn-datastore" attributes="settings">
    <template></template>
    <script>
        Polymer('cwn-datastore', {
            loading: true,
            
            data : {
                nodesLoaded : false,
                linksLoaded : false,
                links : [],
                nodes : []
            },
            lookupMap : {},

            loadingCharts : true,
            chartLoadHandlers : [],

            ready : function() {
                // elements that need charts can push to this array callbacks for when charts are loaded
                window.chartLoadHandlers = this.chartLoadHandlers;
                window.ds = this;

                google.load("visualization", '1', {
                    packages:['corechart', 'table'],
                    callback : function() {
                        this.loadingCharts = false;
                        for( var i = 0; i < this.chartLoadHandlers.length; i++ ) {
                            this.chartLoadHandlers[i]();
                        }
                    }.bind(this)
                });
            },

            reload : function(query, callback) {
                this.reset();
                this.init(query, callback);
            },

            init : function(query, callback) {
                if( !query || typeof query == 'function' ) {
                    this.callback = query;
                    this.loadDefaultGraph();
                } else {
                    this.callback = callback;
                    this.loadCustomGraph(query);
                }
            },

            reset : function() {
                this.loading = true;
                this.data = {
                    nodesLoaded : false,
                    linksLoaded : false,
                    links : [],
                    nodes : []
                };
                lookupMap = {};
            },

            loadDefaultGraph : function() {
                this._loadNodes();
                this._loadLinks();
            },

            loadCustomGraph : function(query) {
                //var query = 'MATCH (n {prmname: "C59"})-[r]->(m) RETURN n.geojson, r.geojson, m.geojson';

                $.ajax({
                    type : 'POST',
                    url : this.settings.neo4jUrl+'/cypher',
                    data : {
                        query : query
                    },
                    success : function(resp) {
                        this._processCustomResponse(resp, query);
                    }.bind(this),
                    error : function(resp) {
                        this.loading = false;
                        if( this.callback ) this.callback(true);
                        alert('Error loading custom cypher: '+query);
                    }.bind(this)
                });
            },

            _processCustomResponse : function(resp, query) {
                if( !resp ) {
                    this.data.nodesLoaded = true;
                    this.data.linksLoaded = true;
                    this._checkLoaded();
                    return alert('Error loading custom cypher: '+query);
                }
                if( !resp.data ) {
                    this.data.nodesLoaded = true;
                    this.data.linksLoaded = true;
                    this._checkLoaded();
                    return alert('Error loading custom cypher: '+query);
                }

                var counts = {
                    query : query,
                    links : 0,
                    nodes : 0
                }

                for( var i = 0; i < resp.data.length; i++ ) {
                    var row = resp.data[i];

                    for( var j = 0; j < row.length; j++ ) {
                        try {
                            json = JSON.parse(row[j]);

                            if( json && json.properties ) {
                                if( json.properties.type == 'Diversion' ) {
                                    this._processLink(json);
                                    counts.links++;
                                } else {
                                    this._processNode(json);
                                    counts.nodes++;
                                }
                            }
                        } catch (e) {
                            console.error(e);
                        }
                    }
                }
                this.data.nodesLoaded = true;
                this.data.linksLoaded = true;
                this._checkLoaded(counts);
            },

            _loadNodes : function() {
                $.ajax({
                    type : 'POST',
                    url : this.settings.neo4jUrl+'/cypher',
                    data : {
                        query : 'MATCH n RETURN n.geojson',
                    },
                    success : function(resp) {
                        var d;
                        for( var i = 0; i < resp.data.length; i++ ) {
                            
                            // crappy sanity checking
                            try {
                                d = JSON.parse(resp.data[i][0]);
                            } catch (e) {
                                continue;
                            }

                            this._processNode(d);
                        }
                        this.data.nodesLoaded = true;
                        this._checkLoaded();
                    }.bind(this),
                    error : function(resp) {
                        this.loading = false;
                        if( this.callback ) this.callback(true);
                        alert('Error retrieving data from: '+this.settings.neo4jUrl+'/cypher');
                    }.bind(this)
                });
            },

            _processNode : function(node) {
                if( !node ) return;
                if( !node.properties ) return;
                if( !node.properties.prmname ) return;

                this._markCalibrationNode(node);
                this.lookupMap[node.properties.prmname] = node;
                this.data.nodes.push(node);
            },

            _processLink : function(link) {
                if( !link ) return;
                if( !link.properties ) return;
                if( !link.properties.prmname ) return;

                this._markCalibrationNode(link);
                this.data.links.push(link);
                this.lookupMap[link.properties.prmname] = link;
            },

            _loadLinks : function() {
                $.ajax({
                    type : 'POST',
                    url : this.settings.neo4jUrl+'/cypher',
                    data : {
                        query : 'start r=rel(*) return r.geojson',
                        params : {}
                    },
                    success : function(resp) {
                        var d;
                        for( var i = 0; i < resp.data.length; i++ ) {
                            
                            // crappy sanity checking
                            try {
                                d = JSON.parse(resp.data[i][0]);
                            } catch (e) {
                                continue;
                            }
                            this._processLink(d);
                        }

                        this.data.linksLoaded = true;
                        this._checkLoaded();
                    }.bind(this),
                    error : function(resp) {
                        // fail silently for now
                    }.bind(this)
                });
            },

            _checkLoaded : function(info) {
                if( this.data.nodesLoaded && this.data.linksLoaded ) {                    
                    this.fire('loaded');
                    this.loading = false;
                    if( this.callback ) this.callback(null, info);
                }
            },

             _markCalibrationNode : function(node) {
                if( node.properties.prmname.indexOf('_') > -1 ) {
                    var parts = node.properties.prmname.split('_');
                    if( !(parts[0].match(/^CN.*/) || parts[1].match(/^CN.*/)) ) {
                        return;
                    }
                } else if( !node.properties.prmname.match(/^CN.*/) ) {
                    return;
                }

                

                var hasIn = false;
                var hasOut = false;

                if( node.properties.terminals ) {
                    for( var i = 0; i < node.properties.terminals.length; i++ ) {
                        if( node.properties.terminals[i] != null ) {
                            hasOut = true;
                            break;
                        }
                    }
                }
                if( node.properties.origins ) {
                    for( var i = 0; i < node.properties.origins.length; i++ ) {
                        if( node.properties.origins[i] != null ) {
                            hasIn = true;
                            break;
                        }
                    }
                } 

                node.properties.calibrationNode = true;
                if( !hasIn && !hasOut ) return;
                
                if( hasIn && hasOut ) node.properties.calibrationMode = 'both';
                else if ( hasIn ) node.properties.calibrationMode = 'in';
                else if ( hasOut ) node.properties.calibrationMode = 'out';
            },
        })
    </script>
</polymer-element>