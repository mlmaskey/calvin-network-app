<dom-module id="cwn-heatmap">
  <template>
    <style>
      :host {
        display: block;
        padding: 7px;
      }
      :host(.active) {
        background-color: rgba(255,255,255, .7);
        border-top: 1px solid white;
        box-shadow: 0 0 5px #333;
      }
      input[type="number"] {
        width: 75px;
        display: inline-block !important;
      }
    </style>

    <div class="layout horizontal">
      <div>
        <input type="checkbox" on-click="toggle"/> Animation Layer
      </div>
      <div class="flex" style="display:none; text-align:center" id="controls">
        <a class="btn btn-default" on-click="previous"><i class="fa fa-arrow-left"></i></a>
        <input type="number" id="monthInput" class="form-control" value="1" on-change="onNumInput" />
        <input type="number" id="yearInput" class="form-control" value="1922" on-change="onNumInput" />
        <a class="btn btn-default" on-click="play"><i id="playIcon" class="fa fa-play"></i></a>
        <a class="btn btn-default" on-click="next"><i class="fa fa-arrow-right"></i></a>
      </div>
    </div>

  </template>
  <script>
    Polymer({
      is: 'cwn-heatmap',

      ready : function() {
        this.showing = false;
        this.playing = false;
        this.cache = {};
        this.date = '1922-01';

        this.start = new Date(1922,0,1);
        this.end = new Date(2002,0,1);
        this.current = new Date(1922,0,1);
        this.setInputs();

        $.get('/network/heatmapMinMax', function(resp){
          this.minMax = resp;
          for( var key in this.minMax ) {
            if( key === 'is' ) continue;
            this.minMax[key].min = Number(this.minMax[key].min);
            this.minMax[key].max = Number(this.minMax[key].max) * 1000;

            if( this.minMax[key].max < 1 ) {
              this.minMax[key].max = 1;
            } else {
              this.minMax[key].max = Math.log(this.minMax[key].max);
            }
          }
        }.bind(this));

        var oneMonth = 30.4*24*60*60*1000;
        var diffMonths = Math.round(Math.abs((this.start.getTime() - this.end.getTime())/(oneMonth)));
      },

      play : function() {
        if( this.playing ) {
          clearInterval(this.playingTimer);
          this.$.playIcon.className = 'fa fa-play';
        } else {
          this.playingTimer = setInterval(this.next.bind(this), 500);
          this.$.playIcon.className = 'fa fa-pause';
        }
        this.playing = !this.playing;
      },

      onNumInput : function() {
        this.current = new Date(Number(this.$.yearInput.value), Number(this.$.monthInput.value)-1, 1);
        this.setDate();
        this.getData();
      },

      previous : function() {
        this.current = new Date(this.current.getFullYear(), this.current.getMonth()-1,1);
        this.setDate();
        this.setInputs();
        this.getData();
      },

      next : function() {
        this.current = new Date(this.current.getFullYear(), this.current.getMonth()+1,1);
        this.setDate();
        this.setInputs();
        this.getData();
      },

      setInputs : function() {
        this.$.monthInput.value = this.current.getMonth()+1;
        this.$.yearInput.value = this.current.getFullYear();
      },

      setDate : function() {
        var m = this.current.getMonth()+1;
        if( m < 10 ) m = '0'+m;
        this.date = this.current.getFullYear()+'-'+m;
      },

      toggle : function() {
        if( this.showing ) {
          this.$.controls.style.display = 'none';
          this.heatmap.hide();
          this.featureLayer.show();
          this.classList.remove('active');
          if( this.playing ) this.play();
        } else {
          this.$.controls.style.display = 'block';
          this.heatmap.show();
          this.featureLayer.hide();
          this.getData();
          this.classList.add('active');
        }

        this.showing = !this.showing;
      },

      init : function(mapEle) {

        this.mapEle = mapEle;
        this.map = mapEle.map;
        this.featureLayer = mapEle.markerLayer;


        this.heatmap = new L.CanvasGeojsonLayer({
          onMouseMove : this.onMouseMove.bind(this),
          onClick : this.onClick.bind(this),
          zIndex : 10
        });
        this.heatmap.addTo(this.map);
      },

      onClick : function(features, e) {
        if( features.length == 0 ) return;

        if( features.length == 1 && features[0].properties.prmname ) {
          window.location.href = '#info/' + features[0].properties.prmname;
          return;
        }

        // grab real features
        var array = [];
        for( var i = 0; i < features.length; i++ ) {
          array.push(CWN.ds.lookupMap[features[i].properties.prmname]);
        }

        this.mapEle.selector.onClick(array);
      },

      onMouseMove : function(features, e) {
        this.lastMouseEvent = e;
        var label = [], linkLabel = '', regionLabel = '';
        var i, f, key;

        for( i = 0; i < features.length; i++ ) {
          f = features[i].properties;

          for( key in f ) {
            if( key !== 'id' && key !== 'scaled' && key !== 'prmname' ) {
              break;
            }
          }

          label.push('<b>'+f.prmname+':</b> '+key+' = '+f[key]);
        }

        if( features.length > 0 ) {
          this.mapEle.showHoverLabel(true, label.join('<br />'), e.containerPoint);
          //this.$.leaflet.style.cursor = 'pointer';
        } else {
          this.mapEle.showHoverLabel(false);
          //this.$.leaflet.style.cursor = '-webkit-grab';
        }
      },


      getData : function() {
        if( this.cache[this.date] ) {
          this.onResponse(this.cache[this.date].data);
        } else {
          $.get('/network/heatmap?date='+this.date, function(resp){
            this.cache[resp.date] = resp;

            if( resp.error ) {
              console.log('No data for: '+this.date);
              this.heatmap.removeAll();
              return;
            }

            for( var i = 0; i < resp.data.length; i++ ) {
              resp.data[i] = JSON.parse(resp.data[i]);
            }

            resp.data.sort(function(a, b){
              if( a.properties.flow ) return -1;
              if( b.properties.flow ) return 1;

              if( a.properties.storage ) return -1;
              if( b.properties.storage ) return 1;

              if( a.properties.inflow ) return -1;
              if( b.properties.inflow ) return 1;

              if( a.properties.sinks ) return -1;
              if( b.properties.sinks ) return 1;

              return 0;
            });

            this.onResponse(resp.data);
          }.bind(this));
        }
      },

      render : function(ctx, point, map, feature) {

        if( feature.geojson.geometry.type === 'Point' ) {

          if( feature.geojson.properties.inflows ) {
            color = 'rgba(0,0,'+
                (255*feature.geojson.properties.value).toFixed(0)+
                ','+
                this.getOpacity(feature.geojson.properties.value)+
                ')';
            this.renderPoint(ctx, point, feature.geojson.properties.value, color);
          }

          if( feature.geojson.properties.sinks ) {
            color = 'rgba('+
              (255*feature.geojson.properties.value).toFixed(0)+
              ',0,0,'+
              this.getOpacity(feature.geojson.properties.value)+
              ')';
            this.renderPoint(ctx, point, feature.geojson.properties.value, color);
          }

          if( feature.geojson.properties.storage ) {
            color = 'rgba(255,153,0,'+
              this.getOpacity(feature.geojson.properties.value)+
              ')';
            this.renderPoint(ctx, point, feature.geojson.properties.value, color);
          }

        } else if( feature.geojson.properties.flow ){
          ctx.beginPath();

          ctx.moveTo(point[0].x, point[0].y);
          ctx.lineTo(point[1].x, point[1].y);

          var o = this.getOpacity(feature.geojson.properties.value);
          color = 'rgba(0,'+
            (255*feature.geojson.properties.value).toFixed(0)+
            ',0,'+o+')';

          ctx.lineCap = 'round';
          ctx.strokeStyle = color;
          ctx.fillStyle = 'rgba(200,200,200,'+o+')';

          var width = Math.ceil(12*feature.geojson.properties.value);

          if( width < 1 ) width = 1;
          ctx.lineWidth = width;

          ctx.stroke();
          ctx.fill();
        }
      },

      getOpacity : function(value) {
        value = value * .9;
        if( value < .1 ) return .1;
        return value;
      },

      getSize : function(value) {
        value = value * 25;
        if( value < 4 ) return 4;
        return value;
      },

      renderPoint : function(ctx, point, value, color) {
        ctx.beginPath();
        ctx.fillStyle = color;
        ctx.arc(point.x, point.y, this.getSize(value), 0, 2*Math.PI);
        ctx.fill();
      },

      onResponse : function(data) {
        this.heatmap.removeAll();
        var arr = [], max = 0;

        if( data.length == 0 ) return;

        for( var i = 0; i < data.length; i++ ) {
          if( !data[i].properties.scaled ) {
            this.scale(data[i].properties);
          }

          this.heatmap.addFeature({
            geojson: data[i],
            render: this.render.bind(this)
          });
        }

        this.heatmap.render();

        // TODO: make sure mouse is still over map
        // update the hover on animation
        if( this.lastMouseEvent && this.playing ) {
          this.heatmap._intersects(this.lastMouseEvent);
          this.heatmap.onMouseMove(this.heatmap.intersectList, this.lastMouseEvent);
        }
      },

      scale : function(properties) {
        for( var key in properties ) {
          if( this.minMax[key] ) {
            properties.value = properties[key] * 1000;

            if( properties.value < 1 ) {
              properties.value = 0;
            } else {
              properties.value = Math.log(properties.value) / this.minMax[key].max;
            }
            if( properties.value > 1 ) {
              properties.value = 1;
            }
          }
        }
        properties.scaled = true;
      }
    });
  </script>
</dom-module>
