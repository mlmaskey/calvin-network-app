<dom-module id="cwn-heatmap">
  <template>
    <style>
      :host {
        display: block;
      }
    </style>

    <div class="layout horizontal">
      <div>
        <input type="checkbox" on-click="toggle"/> Monthly Overlay
      </div>
      <div class="flex">
        <select id="selector" on-change="onTypeChange">
          <template is="dom-repeat" items="{{types}}">
            <option value$="{{item}}">{{item}}</option>
          </template>
        </select>
      </div>
      <div>
        <a class="btn btn-default" on-click="previous"><i class="fa fa-arrow-left"></i></a>
        <input type="number" id="yearInput" value="1922" on-input="onNumInput" />
        <input type="number" id="monthInput" value="1" on-input="onNumInput" />
        <a class="btn btn-default" on-click="play"><i id="playIcon" class="fa fa-play"></i></a>
        <a class="btn btn-default" on-click="next"><i class="fa fa-arrow-right"></i></a>
      </div>
    </div>

  </template>
  <script>
    Polymer({
      is: 'cwn-heatmap',

      ready : function() {
        this.showing = false;
        this.playing = false;
        this.cache = {};
        this.type = 'flow';
        this.types = ['flow','sinks','inflows','evaporation','storage'];
        this.date = '1939-09';
        this.root = 8;

        this.start = new Date(1922,0,1);
        this.end = new Date(2002,0,1);
        this.current = new Date(1922,0,1);
        this.setInputs();

        $.get('/network/heatmapMinMax', function(resp){
          this.minMax = resp;
          for( var key in this.minMax ) {
            if( key === 'is' ) continue;
            this.minMax[key].min = Number(this.minMax[key].min);
            this.minMax[key].max = Number(this.minMax[key].max) * 1000;

            if( this.minMax[key].max < 1 ) {
              this.minMax[key].max = 1;
            } else {
              //this.minMax[key].max = Math.pow(this.minMax[key].max, 1/this.root);
              this.minMax[key].max = Math.log(this.minMax[key].max);
            }
          }
        }.bind(this));

        var oneMonth = 30.4*24*60*60*1000;
        var diffMonths = Math.round(Math.abs((this.start.getTime() - this.end.getTime())/(oneMonth)));
      },

      play : function() {
        if( this.playing ) {
          clearInterval(this.playingTimer);
          this.$.playIcon.className = 'fa fa-play';
        } else {
          this.playingTimer = setInterval(this.next.bind(this), 500);
          this.$.playIcon.className = 'fa fa-pause';
        }
        this.playing = !this.playing;
      },

      previous : function() {
        this.current = new Date(this.current.getFullYear(), this.current.getMonth()-1,1);
        this.setDate();
        this.setInputs();
        this.getData();
      },

      next : function() {
        this.current = new Date(this.current.getFullYear(), this.current.getMonth()+1,1);
        this.setDate();
        this.setInputs();
        this.getData();
      },

      setInputs : function() {
        this.$.monthInput.value = this.current.getMonth()+1;
        this.$.yearInput.value = this.current.getFullYear();
      },

      setDate : function() {
        var m = this.current.getMonth()+1;
        if( m < 10 ) m = '0'+m;
        this.date = this.current.getFullYear()+'-'+m;
      },

      toggle : function() {
        if( this.showing ) {
          this.heatmap.hide();
          this.featureLayer.show();
        } else {
          this.heatmap.show();
          this.featureLayer.hide();
          this.getData();
        }

        this.showing = !this.showing;
      },

      init : function(map, featureLayer) {
        this.map = map;
        this.featureLayer = featureLayer;


        this.heatmap = new L.CanvasGeojsonLayer({
          zIndex : 10
        });
        this.heatmap.addTo(this.map);
      },

      onTypeChange : function() {
        this.type = this.$.selector.value;
        this.getData();
      },

      getData : function() {
        if( this.cache[this.date] ) {
          this.onResponse(this.cache[this.date].data);
        } else {
          $.get('/network/heatmap?date='+this.date, function(resp){
            this.cache[resp.date] = resp;

            if( resp.error ) {
              console.log('No data for: '+this.date);
              this.heatmap.removeAll();
              return;
            }

            for( var i = 0; i < resp.data.length; i++ ) {
              resp.data[i] = JSON.parse(resp.data[i]);
            }

            this.onResponse(resp.data);
          }.bind(this));
        }
      },

      render : function(ctx, point, map, feature) {

        if( feature.geojson.geometry.type === 'Point' ) {

          if( feature.geojson.properties.inflows ) {
            color = 'rgba(0,0,'+
                (255*feature.geojson.properties.inflows).toFixed(0)+
                ','+
                this.getOpacity(feature.geojson.properties.inflows)+
                ')';
            this.renderPoint(ctx, point, feature.geojson.properties.inflows, color);
          }
          if( feature.geojson.properties.sinks ) {
            color = 'rgba('+
              (255*feature.geojson.properties.sinks).toFixed(0)+
              ',0,0,'+
              this.getOpacity(feature.geojson.properties.sinks)+
              ')';
            this.renderPoint(ctx, point, feature.geojson.properties.sinks, color);
          }

        } else if( feature.geojson.properties.flow ){
          ctx.beginPath();

          ctx.moveTo(point[0].x, point[0].y);
          ctx.lineTo(point[1].x, point[1].y);

          var o = this.getOpacity(feature.geojson.properties.flow);
          color = 'rgba(0,'+
            (255*feature.geojson.properties.flow).toFixed(0)+
            ',0,'+o+')';

          ctx.lineCap="round";
          ctx.strokeStyle = color;
          ctx.fillStyle = 'rgba(200,200,200,'+o+')';

          var width = Math.ceil(12*feature.geojson.properties.flow);

          if( width < 1 ) width = 1;
          ctx.lineWidth = width;

          ctx.stroke();
          ctx.fill();
        }
      },

      getOpacity : function(value) {
        value = value * .9;
        if( value < .1 ) return .1;
        return value;
      },

      getSize : function(value) {
        value = value * 25;
        if( value < 4 ) return 4;
        return value;
      },

      renderPoint : function(ctx, point, value, color) {
        ctx.beginPath();
        ctx.fillStyle = color;
        ctx.arc(point.x, point.y, this.getSize(value), 0, 2*Math.PI);
        ctx.fill();
      },

      onResponse : function(data) {
        this.heatmap.removeAll();
        var arr = [], max = 0;

        /*for( var i = 0; i < data.length; i++ ) {
          if( !data[i][this.type] ) continue;
          arr.push([
            Number(data[i].x),
            Number(data[i].y),
            data[i][this.type],
          ]);
        }*/


        if( data.length == 0 ) return;

        /*arr.sort(function(a, b){
          if( a[2] < b[2] ) return -1;
          if( a[2] > b[2] ) return 1;
          return 0;
        });

        max = Math.floor(.9 * arr.length);
        max = arr[max][2];*/

        /*for( var i = 0; i < arr.length; i++ ) {
          arr[i][2] = arr[i][2] / max;
          if( arr[i][2] > 1 ) {
            arr[i][2] = 1;
          } else if( arr[i][2] < 0 ) {
            arr[i][2] = 0;
          }

          this.heatmap.addFeature({
            geojson: {
              geometry : {
                type : 'Point',
                coordinates : [arr[i][1], arr[i][0]]
              },
              properties : {
                value : arr[i][2]
              }
            },
            render: this.render.bind(this)
          });
        }*/

        for( var i = 0; i < data.length; i++ ) {
          if( !data[i].properties.scaled ) {
            this.scale(data[i].properties);
          }

          this.heatmap.addFeature({
            geojson: data[i],
            render: this.render.bind(this)
          });
        }

        this.heatmap.render();
      },

      scale : function(properties) {
        for( var key in properties ) {
          if( this.minMax[key] ) {
            properties[key] = properties[key] * 1000;

            if( properties[key] < 1 ) {
              properties[key] = 0;
            } else {
              //properties[key] = Math.pow(properties[key], 1/this.root) / this.minMax[key].max;
              properties[key] = Math.log(properties[key]) / this.minMax[key].max;
            }
            if( properties[key] > 1 ) {
              properties[key] = 1;
            }
          }
        }
        properties.scaled = true;
      }
    });
  </script>
</dom-module>
